"""
独立桌面版三维土体重建程序
基于RBF插值和GemPy的土体域建模系统
"""
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import pyvista as pv
import pyvistaqt as pvqt
from threading import Thread
import os
import json
from typing import Dict, Tuple, Optional, List

# 导入自定义模块
from rbf_interpolation import BoreholeRBFInterpolator, create_sample_borehole_data

class SoilReconstructionGUI:
    """三维土体重建桌面应用程序"""
    
    def __init__(self, root):
        self.root = root
        self.setup_gui()
        self.initialize_variables()
        
    def setup_gui(self):
        """设置GUI界面"""
        self.root.title("🗺️ 三维土体重建系统 v1.0")
        self.root.geometry("1200x800")
        self.root.configure(bg='#f0f0f0')
        
        # 设置样式
        style = ttk.Style()
        style.theme_use('clam')
        
        # 创建主框架
        self.create_main_layout()
        
    def create_main_layout(self):
        """创建主布局"""
        # 顶部标题
        title_frame = tk.Frame(self.root, bg='#2c3e50', height=60)
        title_frame.pack(fill='x', padx=5, pady=5)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame, 
            text="🗺️ 三维土体重建系统",
            font=('Arial', 18, 'bold'),
            fg='white', bg='#2c3e50'
        )
        title_label.pack(expand=True)
        
        # 主面板
        main_paned = ttk.PanedWindow(self.root, orient='horizontal')
        main_paned.pack(fill='both', expand=True, padx=5, pady=5)
        
        # 左侧控制面板
        self.create_control_panel(main_paned)
        
        # 右侧显示面板
        self.create_display_panel(main_paned)
        
        # 底部状态栏
        self.create_status_bar()
        
    def create_control_panel(self, parent):
        """创建左侧控制面板"""
        control_frame = ttk.Frame(parent)
        parent.add(control_frame, weight=1)
        
        # 创建notebook
        notebook = ttk.Notebook(control_frame)
        notebook.pack(fill='both', expand=True, padx=5, pady=5)
        
        # 土体域设置页面
        self.create_domain_tab(notebook)
        
        # 钻孔数据页面
        self.create_borehole_tab(notebook)
        
        # RBF参数页面
        self.create_rbf_tab(notebook)
        
        # 重建设置页面
        self.create_reconstruction_tab(notebook)
        
    def create_domain_tab(self, parent):
        """创建土体域设置页面"""
        domain_frame = ttk.Frame(parent)
        parent.add(domain_frame, text="🏗️ 土体域设置")
        
        # X方向设置
        x_frame = ttk.LabelFrame(domain_frame, text="X方向 (m)", padding="10")
        x_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(x_frame, text="最小值:").grid(row=0, column=0, sticky='w', padx=5)
        self.x_min_var = tk.DoubleVar(value=0.0)\n        x_min_entry = ttk.Entry(x_frame, textvariable=self.x_min_var, width=15)\n        x_min_entry.grid(row=0, column=1, padx=5)\n        \n        ttk.Label(x_frame, text=\"最大值:\").grid(row=0, column=2, sticky='w', padx=5)\n        self.x_max_var = tk.DoubleVar(value=100.0)\n        x_max_entry = ttk.Entry(x_frame, textvariable=self.x_max_var, width=15)\n        x_max_entry.grid(row=0, column=3, padx=5)\n        \n        ttk.Label(x_frame, text=\"网格数:\").grid(row=1, column=0, sticky='w', padx=5)\n        self.x_res_var = tk.IntVar(value=50)\n        x_res_spin = ttk.Spinbox(x_frame, from_=10, to=200, textvariable=self.x_res_var, width=15)\n        x_res_spin.grid(row=1, column=1, padx=5)\n        \n        # Y方向设置\n        y_frame = ttk.LabelFrame(domain_frame, text=\"Y方向 (m)\", padding=\"10\")\n        y_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(y_frame, text=\"最小值:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.y_min_var = tk.DoubleVar(value=0.0)\n        y_min_entry = ttk.Entry(y_frame, textvariable=self.y_min_var, width=15)\n        y_min_entry.grid(row=0, column=1, padx=5)\n        \n        ttk.Label(y_frame, text=\"最大值:\").grid(row=0, column=2, sticky='w', padx=5)\n        self.y_max_var = tk.DoubleVar(value=100.0)\n        y_max_entry = ttk.Entry(y_frame, textvariable=self.y_max_var, width=15)\n        y_max_entry.grid(row=0, column=3, padx=5)\n        \n        ttk.Label(y_frame, text=\"网格数:\").grid(row=1, column=0, sticky='w', padx=5)\n        self.y_res_var = tk.IntVar(value=50)\n        y_res_spin = ttk.Spinbox(y_frame, from_=10, to=200, textvariable=self.y_res_var, width=15)\n        y_res_spin.grid(row=1, column=1, padx=5)\n        \n        # Z方向设置\n        z_frame = ttk.LabelFrame(domain_frame, text=\"Z方向 (m)\", padding=\"10\")\n        z_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(z_frame, text=\"最小值:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.z_min_var = tk.DoubleVar(value=0.0)\n        z_min_entry = ttk.Entry(z_frame, textvariable=self.z_min_var, width=15)\n        z_min_entry.grid(row=0, column=1, padx=5)\n        \n        ttk.Label(z_frame, text=\"最大值:\").grid(row=0, column=2, sticky='w', padx=5)\n        self.z_max_var = tk.DoubleVar(value=50.0)\n        z_max_entry = ttk.Entry(z_frame, textvariable=self.z_max_var, width=15)\n        z_max_entry.grid(row=0, column=3, padx=5)\n        \n        ttk.Label(z_frame, text=\"网格数:\").grid(row=1, column=0, sticky='w', padx=5)\n        self.z_res_var = tk.IntVar(value=25)\n        z_res_spin = ttk.Spinbox(z_frame, from_=10, to=100, textvariable=self.z_res_var, width=15)\n        z_res_spin.grid(row=1, column=1, padx=5)\n        \n        # 快捷设置\n        quick_frame = ttk.LabelFrame(domain_frame, text=\"快捷设置\", padding=\"10\")\n        quick_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Button(quick_frame, text=\"小型基坑 (50x50x20m)\", \n                  command=lambda: self.set_domain_preset(50, 50, 20)).pack(side='left', padx=5)\n        ttk.Button(quick_frame, text=\"中型基坑 (100x100x30m)\", \n                  command=lambda: self.set_domain_preset(100, 100, 30)).pack(side='left', padx=5)\n        ttk.Button(quick_frame, text=\"大型基坑 (200x200x50m)\", \n                  command=lambda: self.set_domain_preset(200, 200, 50)).pack(side='left', padx=5)\n        \n        # 域信息显示\n        info_frame = ttk.LabelFrame(domain_frame, text=\"域信息\", padding=\"10\")\n        info_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.domain_info_var = tk.StringVar()\n        info_label = ttk.Label(info_frame, textvariable=self.domain_info_var, font=('Arial', 9))\n        info_label.pack()\n        \n        self.update_domain_info()\n        \n    def create_borehole_tab(self, parent):\n        \"\"\"创建钻孔数据页面\"\"\"\n        borehole_frame = ttk.Frame(parent)\n        parent.add(borehole_frame, text=\"🕳️ 钻孔数据\")\n        \n        # 数据来源选择\n        source_frame = ttk.LabelFrame(borehole_frame, text=\"数据来源\", padding=\"10\")\n        source_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.data_source_var = tk.StringVar(value=\"示例数据\")\n        \n        ttk.Radiobutton(source_frame, text=\"生成示例数据\", variable=self.data_source_var, \n                       value=\"示例数据\").pack(anchor='w')\n        ttk.Radiobutton(source_frame, text=\"导入CSV文件\", variable=self.data_source_var, \n                       value=\"CSV文件\").pack(anchor='w')\n        \n        # 示例数据设置\n        sample_frame = ttk.LabelFrame(borehole_frame, text=\"示例数据设置\", padding=\"10\")\n        sample_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(sample_frame, text=\"密集区域点数:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.dense_points_var = tk.IntVar(value=20)\n        ttk.Spinbox(sample_frame, from_=5, to=100, textvariable=self.dense_points_var, \n                   width=10).grid(row=0, column=1, padx=5)\n        \n        ttk.Label(sample_frame, text=\"稀疏区域点数:\").grid(row=0, column=2, sticky='w', padx=5)\n        self.sparse_points_var = tk.IntVar(value=15)\n        ttk.Spinbox(sample_frame, from_=5, to=50, textvariable=self.sparse_points_var, \n                   width=10).grid(row=0, column=3, padx=5)\n        \n        ttk.Label(sample_frame, text=\"噪声水平:\").grid(row=1, column=0, sticky='w', padx=5)\n        self.noise_var = tk.DoubleVar(value=1.0)\n        ttk.Scale(sample_frame, from_=0.1, to=3.0, variable=self.noise_var, \n                 orient='horizontal', length=100).grid(row=1, column=1, padx=5)\n        \n        # 文件操作\n        file_frame = ttk.LabelFrame(borehole_frame, text=\"文件操作\", padding=\"10\")\n        file_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Button(file_frame, text=\"📁 导入CSV\", command=self.load_csv_data).pack(side='left', padx=5)\n        ttk.Button(file_frame, text=\"💾 导出数据\", command=self.export_data).pack(side='left', padx=5)\n        ttk.Button(file_frame, text=\"🎲 生成示例\", command=self.generate_sample_data).pack(side='left', padx=5)\n        \n        # 数据信息\n        self.data_info_var = tk.StringVar(value=\"暂无数据\")\n        ttk.Label(borehole_frame, textvariable=self.data_info_var, \n                 font=('Arial', 10, 'italic')).pack(pady=5)\n        \n    def create_rbf_tab(self, parent):\n        \"\"\"创建RBF参数页面\"\"\"\n        rbf_frame = ttk.Frame(parent)\n        parent.add(rbf_frame, text=\"🔧 RBF参数\")\n        \n        # 核函数设置\n        kernel_frame = ttk.LabelFrame(rbf_frame, text=\"核函数设置\", padding=\"10\")\n        kernel_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(kernel_frame, text=\"核函数类型:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.kernel_var = tk.StringVar(value=\"multiquadric\")\n        kernel_combo = ttk.Combobox(kernel_frame, textvariable=self.kernel_var, width=20)\n        kernel_combo['values'] = ('multiquadric', 'gaussian', 'thin_plate_spline', \n                                 'linear', 'cubic', 'quintic')\n        kernel_combo.grid(row=0, column=1, padx=5)\n        \n        # Epsilon参数\n        epsilon_frame = ttk.LabelFrame(rbf_frame, text=\"Epsilon设置\", padding=\"10\")\n        epsilon_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.epsilon_auto_var = tk.BooleanVar(value=True)\n        ttk.Checkbutton(epsilon_frame, text=\"自动优化\", \n                       variable=self.epsilon_auto_var).pack(anchor='w')\n        \n        epsilon_manual_frame = tk.Frame(epsilon_frame)\n        epsilon_manual_frame.pack(fill='x', pady=5)\n        \n        ttk.Label(epsilon_manual_frame, text=\"手动值:\").pack(side='left', padx=5)\n        self.epsilon_var = tk.DoubleVar(value=1.0)\n        ttk.Scale(epsilon_manual_frame, from_=0.001, to=10.0, variable=self.epsilon_var, \n                 orient='horizontal', length=200).pack(side='left', padx=5)\n        \n        # 其他参数\n        other_frame = ttk.LabelFrame(rbf_frame, text=\"其他参数\", padding=\"10\")\n        other_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(other_frame, text=\"平滑参数:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.smoothing_var = tk.DoubleVar(value=0.0)\n        ttk.Scale(other_frame, from_=0.0, to=1.0, variable=self.smoothing_var, \n                 orient='horizontal', length=150).grid(row=0, column=1, padx=5)\n        \n        self.use_polynomial_var = tk.BooleanVar(value=False)\n        ttk.Checkbutton(other_frame, text=\"使用多项式趋势\", \n                       variable=self.use_polynomial_var).grid(row=1, column=0, columnspan=2, sticky='w')\n        \n    def create_reconstruction_tab(self, parent):\n        \"\"\"创建重建设置页面\"\"\"\n        recon_frame = ttk.Frame(parent)\n        parent.add(recon_frame, text=\"🏗️ 重建设置\")\n        \n        # 重建方法\n        method_frame = ttk.LabelFrame(recon_frame, text=\"重建方法\", padding=\"10\")\n        method_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.recon_method_var = tk.StringVar(value=\"RBF插值\")\n        ttk.Radiobutton(method_frame, text=\"RBF插值重建\", variable=self.recon_method_var, \n                       value=\"RBF插值\").pack(anchor='w')\n        ttk.Radiobutton(method_frame, text=\"GemPy地质建模\", variable=self.recon_method_var, \n                       value=\"GemPy建模\").pack(anchor='w')\n        ttk.Radiobutton(method_frame, text=\"混合建模\", variable=self.recon_method_var, \n                       value=\"混合建模\").pack(anchor='w')\n        \n        # 渲染设置\n        render_frame = ttk.LabelFrame(recon_frame, text=\"渲染设置\", padding=\"10\")\n        render_frame.pack(fill='x', padx=5, pady=5)\n        \n        ttk.Label(render_frame, text=\"渲染模式:\").grid(row=0, column=0, sticky='w', padx=5)\n        self.render_mode_var = tk.StringVar(value=\"体积渲染\")\n        render_combo = ttk.Combobox(render_frame, textvariable=self.render_mode_var, width=15)\n        render_combo['values'] = ('体积渲染', '等值面', '切片', '轮廓')\n        render_combo.grid(row=0, column=1, padx=5)\n        \n        self.show_points_var = tk.BooleanVar(value=True)\n        ttk.Checkbutton(render_frame, text=\"显示钻孔点\", \n                       variable=self.show_points_var).grid(row=1, column=0, columnspan=2, sticky='w')\n        \n        # 执行按钮\n        action_frame = ttk.Frame(recon_frame)\n        action_frame.pack(fill='x', padx=5, pady=20)\n        \n        ttk.Button(action_frame, text=\"🚀 开始重建\", command=self.start_reconstruction, \n                  style='Accent.TButton').pack(pady=10)\n        \n        ttk.Button(action_frame, text=\"📊 显示结果\", command=self.show_3d_result).pack(pady=5)\n        \n    def create_display_panel(self, parent):\n        \"\"\"创建右侧显示面板\"\"\"\n        display_frame = ttk.Frame(parent)\n        parent.add(display_frame, weight=2)\n        \n        # 创建显示选项卡\n        display_notebook = ttk.Notebook(display_frame)\n        display_notebook.pack(fill='both', expand=True, padx=5, pady=5)\n        \n        # 2D预览页面\n        self.create_2d_preview_tab(display_notebook)\n        \n        # 3D显示页面\n        self.create_3d_display_tab(display_notebook)\n        \n        # 统计信息页面\n        self.create_stats_tab(display_notebook)\n        \n    def create_2d_preview_tab(self, parent):\n        \"\"\"创建2D预览页面\"\"\"\n        preview_frame = ttk.Frame(parent)\n        parent.add(preview_frame, text=\"📊 2D预览\")\n        \n        # 创建matplotlib图形\n        self.fig_2d = Figure(figsize=(8, 6), dpi=100)\n        self.canvas_2d = FigureCanvasTkAgg(self.fig_2d, preview_frame)\n        self.canvas_2d.get_tk_widget().pack(fill='both', expand=True)\n        \n        # 工具栏\n        toolbar_frame = tk.Frame(preview_frame)\n        toolbar_frame.pack(fill='x')\n        \n        ttk.Button(toolbar_frame, text=\"🔄 刷新\", command=self.update_2d_preview).pack(side='left', padx=5)\n        ttk.Button(toolbar_frame, text=\"💾 保存图片\", command=self.save_2d_plot).pack(side='left', padx=5)\n        \n    def create_3d_display_tab(self, parent):\n        \"\"\"创建3D显示页面\"\"\"\n        display_3d_frame = ttk.Frame(parent)\n        parent.add(display_3d_frame, text=\"🎯 3D显示\")\n        \n        # 3D显示提示\n        info_label = ttk.Label(display_3d_frame, \n                              text=\"3D可视化将在独立窗口中显示\\n点击'显示结果'按钮查看三维模型\", \n                              font=('Arial', 12), \n                              justify='center')\n        info_label.pack(expand=True)\n        \n        # 3D控制按钮\n        control_3d_frame = tk.Frame(display_3d_frame)\n        control_3d_frame.pack(pady=20)\n        \n        ttk.Button(control_3d_frame, text=\"🎯 打开3D视图\", \n                  command=self.show_3d_result).pack(pady=5)\n        ttk.Button(control_3d_frame, text=\"📷 保存3D截图\", \n                  command=self.save_3d_screenshot).pack(pady=5)\n        \n    def create_stats_tab(self, parent):\n        \"\"\"创建统计信息页面\"\"\"\n        stats_frame = ttk.Frame(parent)\n        parent.add(stats_frame, text=\"📈 统计信息\")\n        \n        # 创建文本框显示统计信息\n        self.stats_text = tk.Text(stats_frame, wrap='word', font=('Consolas', 10))\n        scrollbar = ttk.Scrollbar(stats_frame, orient='vertical', command=self.stats_text.yview)\n        self.stats_text.configure(yscrollcommand=scrollbar.set)\n        \n        self.stats_text.pack(side='left', fill='both', expand=True)\n        scrollbar.pack(side='right', fill='y')\n        \n    def create_status_bar(self):\n        \"\"\"创建状态栏\"\"\"\n        self.status_bar = tk.Frame(self.root, relief='sunken', bd=1, bg='#e0e0e0')\n        self.status_bar.pack(side='bottom', fill='x')\n        \n        self.status_var = tk.StringVar(value=\"就绪\")\n        status_label = tk.Label(self.status_bar, textvariable=self.status_var, \n                               bg='#e0e0e0', anchor='w')\n        status_label.pack(side='left', padx=5)\n        \n        # 进度条\n        self.progress = ttk.Progressbar(self.status_bar, length=200, mode='determinate')\n        self.progress.pack(side='right', padx=5, pady=2)\n        \n    def initialize_variables(self):\n        \"\"\"初始化变量\"\"\"\n        self.coords = None\n        self.values = None\n        self.interpolator = None\n        self.reconstruction_result = None\n        self.pit_bounds = None\n        \n        # 绑定事件\n        for var in [self.x_min_var, self.x_max_var, self.x_res_var,\n                   self.y_min_var, self.y_max_var, self.y_res_var,\n                   self.z_min_var, self.z_max_var, self.z_res_var]:\n            var.trace('w', lambda *args: self.update_domain_info())\n            \n    def set_domain_preset(self, x_size, y_size, z_size):\n        \"\"\"设置域预设值\"\"\"\n        self.x_min_var.set(0)\n        self.x_max_var.set(x_size)\n        self.y_min_var.set(0)\n        self.y_max_var.set(y_size)\n        self.z_min_var.set(0)\n        self.z_max_var.set(z_size)\n        \n        # 根据域大小调整网格分辨率\n        self.x_res_var.set(min(100, max(20, x_size // 2)))\n        self.y_res_var.set(min(100, max(20, y_size // 2)))\n        self.z_res_var.set(min(50, max(10, z_size // 2)))\n        \n    def update_domain_info(self):\n        \"\"\"更新域信息显示\"\"\"\n        try:\n            x_range = self.x_max_var.get() - self.x_min_var.get()\n            y_range = self.y_max_var.get() - self.y_min_var.get()\n            z_range = self.z_max_var.get() - self.z_min_var.get()\n            \n            volume = x_range * y_range * z_range\n            total_points = self.x_res_var.get() * self.y_res_var.get() * self.z_res_var.get()\n            \n            info_text = (f\"域大小: {x_range:.1f} × {y_range:.1f} × {z_range:.1f} m³\\n\"\n                        f\"体积: {volume:,.0f} m³\\n\"\n                        f\"网格点数: {total_points:,} 个\")\n            \n            self.domain_info_var.set(info_text)\n        except:\n            self.domain_info_var.set(\"域参数设置有误\")\n            \n    def generate_sample_data(self):\n        \"\"\"生成示例数据\"\"\"\n        try:\n            self.status_var.set(\"正在生成示例数据...\")\n            self.progress['value'] = 20\n            self.root.update()\n            \n            # 获取基坑边界（域的中心40%区域作为密集区域）\n            x_center = (self.x_min_var.get() + self.x_max_var.get()) / 2\n            y_center = (self.y_min_var.get() + self.y_max_var.get()) / 2\n            x_range = (self.x_max_var.get() - self.x_min_var.get()) * 0.4\n            y_range = (self.y_max_var.get() - self.y_min_var.get()) * 0.4\n            \n            self.pit_bounds = {\n                'x': (x_center - x_range/2, x_center + x_range/2),\n                'y': (y_center - y_range/2, y_center + y_range/2)\n            }\n            \n            self.progress['value'] = 50\n            self.root.update()\n            \n            # 生成数据\n            self.coords, self.values, _ = create_sample_borehole_data(\n                n_dense=self.dense_points_var.get(),\n                n_sparse=self.sparse_points_var.get(),\n                pit_bounds=self.pit_bounds\n            )\n            \n            # 缩放到实际域大小\n            self.coords[:, 0] = np.interp(self.coords[:, 0], [0, 100], \n                                         [self.x_min_var.get(), self.x_max_var.get()])\n            self.coords[:, 1] = np.interp(self.coords[:, 1], [0, 100], \n                                         [self.y_min_var.get(), self.y_max_var.get()])\n            \n            # 添加噪声\n            self.values += np.random.normal(0, self.noise_var.get(), len(self.values))\n            \n            self.progress['value'] = 100\n            self.root.update()\n            \n            # 更新信息显示\n            info_text = (f\"数据点总数: {len(self.coords)}\\n\"\n                        f\"X范围: {self.coords[:, 0].min():.1f} ~ {self.coords[:, 0].max():.1f} m\\n\"\n                        f\"Y范围: {self.coords[:, 1].min():.1f} ~ {self.coords[:, 1].max():.1f} m\\n\"\n                        f\"值范围: {self.values.min():.2f} ~ {self.values.max():.2f}\")\n            self.data_info_var.set(info_text)\n            \n            # 更新2D预览\n            self.update_2d_preview()\n            \n            self.status_var.set(\"示例数据生成完成\")\n            self.progress['value'] = 0\n            \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"生成示例数据失败: {str(e)}\")\n            self.status_var.set(\"生成数据失败\")\n            self.progress['value'] = 0\n            \n    def load_csv_data(self):\n        \"\"\"加载CSV数据文件\"\"\"\n        try:\n            file_path = filedialog.askopenfilename(\n                title=\"选择CSV文件\",\n                filetypes=[(\"CSV文件\", \"*.csv\"), (\"所有文件\", \"*.*\")]\n            )\n            \n            if not file_path:\n                return\n                \n            self.status_var.set(\"正在加载数据文件...\")\n            self.progress['value'] = 30\n            self.root.update()\n            \n            # 读取CSV文件\n            df = pd.read_csv(file_path)\n            \n            # 检查必需列\n            required_cols = ['x', 'y', 'value']\n            if not all(col in df.columns for col in required_cols):\n                messagebox.showerror(\"错误\", f\"CSV文件必须包含列: {required_cols}\")\n                return\n                \n            self.progress['value'] = 70\n            self.root.update()\n            \n            # 提取数据\n            if 'z' in df.columns:\n                self.coords = df[['x', 'y', 'z']].values\n            else:\n                self.coords = df[['x', 'y']].values\n            self.values = df['value'].values\n            \n            self.progress['value'] = 100\n            self.root.update()\n            \n            # 更新信息显示\n            info_text = (f\"数据点总数: {len(self.coords)}\\n\"\n                        f\"X范围: {self.coords[:, 0].min():.1f} ~ {self.coords[:, 0].max():.1f} m\\n\"\n                        f\"Y范围: {self.coords[:, 1].min():.1f} ~ {self.coords[:, 1].max():.1f} m\\n\"\n                        f\"值范围: {self.values.min():.2f} ~ {self.values.max():.2f}\")\n            self.data_info_var.set(info_text)\n            \n            # 更新2D预览\n            self.update_2d_preview()\n            \n            self.status_var.set(f\"成功加载 {len(self.coords)} 个数据点\")\n            self.progress['value'] = 0\n            \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"加载数据文件失败: {str(e)}\")\n            self.status_var.set(\"加载数据失败\")\n            self.progress['value'] = 0\n            \n    def export_data(self):\n        \"\"\"导出数据\"\"\"\n        if self.coords is None or self.values is None:\n            messagebox.showwarning(\"警告\", \"没有可导出的数据\")\n            return\n            \n        try:\n            file_path = filedialog.asksaveasfilename(\n                title=\"保存数据文件\",\n                defaultextension=\".csv\",\n                filetypes=[(\"CSV文件\", \"*.csv\"), (\"所有文件\", \"*.*\")]\n            )\n            \n            if not file_path:\n                return\n                \n            # 创建DataFrame\n            df = pd.DataFrame({\n                'x': self.coords[:, 0],\n                'y': self.coords[:, 1],\n                'value': self.values\n            })\n            \n            if self.coords.shape[1] == 3:\n                df['z'] = self.coords[:, 2]\n                \n            df.to_csv(file_path, index=False)\n            \n            messagebox.showinfo(\"成功\", f\"数据已保存到: {file_path}\")\n            self.status_var.set(\"数据导出完成\")\n            \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"导出数据失败: {str(e)}\")\n            \n    def update_2d_preview(self):\n        \"\"\"更新2D预览图\"\"\"\n        if self.coords is None or self.values is None:\n            return\n            \n        try:\n            self.fig_2d.clear()\n            \n            # 创建子图\n            ax1 = self.fig_2d.add_subplot(121)\n            ax2 = self.fig_2d.add_subplot(122)\n            \n            # 数据分布图\n            scatter = ax1.scatter(self.coords[:, 0], self.coords[:, 1], \n                                c=self.values, cmap='viridis', s=50, alpha=0.7)\n            ax1.set_xlabel('X坐标 (m)')\n            ax1.set_ylabel('Y坐标 (m)')\n            ax1.set_title('钻孔数据分布')\n            ax1.grid(True, alpha=0.3)\n            \n            # 添加基坑边界\n            if self.pit_bounds:\n                x_bounds = self.pit_bounds['x']\n                y_bounds = self.pit_bounds['y']\n                ax1.add_patch(plt.Rectangle((x_bounds[0], y_bounds[0]), \n                                          x_bounds[1] - x_bounds[0],\n                                          y_bounds[1] - y_bounds[0],\n                                          fill=False, edgecolor='red', \n                                          linewidth=2, linestyle='--'))\n                ax1.text((x_bounds[0] + x_bounds[1])/2, y_bounds[1], \n                        '基坑区域', ha='center', color='red', fontweight='bold')\n            \n            self.fig_2d.colorbar(scatter, ax=ax1, label='值')\n            \n            # 值分布直方图\n            ax2.hist(self.values, bins=20, alpha=0.7, color='skyblue', edgecolor='navy')\n            ax2.set_xlabel('值')\n            ax2.set_ylabel('频次')\n            ax2.set_title('数据值分布')\n            ax2.grid(True, alpha=0.3)\n            \n            self.fig_2d.tight_layout()\n            self.canvas_2d.draw()\n            \n        except Exception as e:\n            print(f\"更新2D预览失败: {e}\")\n            \n    def save_2d_plot(self):\n        \"\"\"保存2D图片\"\"\"\n        try:\n            file_path = filedialog.asksaveasfilename(\n                title=\"保存图片\",\n                defaultextension=\".png\",\n                filetypes=[(\"PNG文件\", \"*.png\"), (\"JPG文件\", \"*.jpg\"), (\"所有文件\", \"*.*\")]\n            )\n            \n            if file_path:\n                self.fig_2d.savefig(file_path, dpi=300, bbox_inches='tight')\n                messagebox.showinfo(\"成功\", f\"图片已保存到: {file_path}\")\n                \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"保存图片失败: {str(e)}\")\n            \n    def start_reconstruction(self):\n        \"\"\"开始三维重建\"\"\"\n        if self.coords is None or self.values is None:\n            messagebox.showwarning(\"警告\", \"请先加载或生成钻孔数据\")\n            return\n            \n        try:\n            self.status_var.set(\"正在进行三维重建...\")\n            self.progress['value'] = 10\n            self.root.update()\n            \n            # 创建RBF插值器\n            epsilon = 'scale' if self.epsilon_auto_var.get() else self.epsilon_var.get()\n            degree = 1 if self.use_polynomial_var.get() else None\n            \n            self.interpolator = BoreholeRBFInterpolator(\n                foundation_pit_bounds=self.pit_bounds,\n                kernel=self.kernel_var.get(),\n                epsilon=epsilon,\n                smoothing=self.smoothing_var.get(),\n                degree=degree\n            )\n            \n            self.progress['value'] = 30\n            self.root.update()\n            \n            # 拟合插值器\n            self.interpolator.fit(self.coords, self.values, optimize_params=True)\n            \n            self.progress['value'] = 60\n            self.root.update()\n            \n            # 创建插值网格\n            extent = [\n                self.x_min_var.get(), self.x_max_var.get(),\n                self.y_min_var.get(), self.y_max_var.get(),\n                self.z_min_var.get(), self.z_max_var.get()\n            ]\n            \n            resolution = [\n                self.x_res_var.get(),\n                self.y_res_var.get(),\n                self.z_res_var.get()\n            ]\n            \n            # 生成网格点\n            x = np.linspace(extent[0], extent[1], resolution[0])\n            y = np.linspace(extent[2], extent[3], resolution[1])\n            z = np.linspace(extent[4], extent[5], resolution[2])\n            \n            xg, yg, zg = np.meshgrid(x, y, z, indexing='ij')\n            grid_coords = np.column_stack([xg.ravel(), yg.ravel(), zg.ravel()])\n            \n            self.progress['value'] = 80\n            self.root.update()\n            \n            # 进行插值\n            interpolated_values = self.interpolator.predict(grid_coords[:, :2], method='adaptive')\n            interpolated_grid = interpolated_values.reshape(resolution, order='F')\n            \n            # 保存重建结果\n            self.reconstruction_result = {\n                'grid': interpolated_grid,\n                'extent': extent,\n                'resolution': resolution,\n                'coords': grid_coords,\n                'values': interpolated_values\n            }\n            \n            self.progress['value'] = 100\n            self.root.update()\n            \n            # 更新统计信息\n            self.update_stats_display()\n            \n            self.status_var.set(\"三维重建完成\")\n            self.progress['value'] = 0\n            \n            messagebox.showinfo(\"成功\", \"三维土体重建完成！\")\n            \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"三维重建失败: {str(e)}\")\n            self.status_var.set(\"重建失败\")\n            self.progress['value'] = 0\n            \n    def update_stats_display(self):\n        \"\"\"更新统计信息显示\"\"\"\n        if not self.reconstruction_result:\n            return\n            \n        try:\n            # 获取重建结果统计\n            grid = self.reconstruction_result['grid']\n            extent = self.reconstruction_result['extent']\n            resolution = self.reconstruction_result['resolution']\n            \n            stats_text = f\"\"\"\n=== 三维土体重建统计信息 ===\n\n【域设置】\nX范围: {extent[0]:.1f} ~ {extent[1]:.1f} m\nY范围: {extent[2]:.1f} ~ {extent[3]:.1f} m\nZ范围: {extent[4]:.1f} ~ {extent[5]:.1f} m\n网格分辨率: {resolution[0]} × {resolution[1]} × {resolution[2]}\n总网格点数: {np.prod(resolution):,}\n\n【原始数据】\n钻孔总数: {len(self.coords)}\nX坐标范围: {self.coords[:, 0].min():.1f} ~ {self.coords[:, 0].max():.1f} m\nY坐标范围: {self.coords[:, 1].min():.1f} ~ {self.coords[:, 1].max():.1f} m\n观测值范围: {self.values.min():.2f} ~ {self.values.max():.2f}\n观测值均值: {self.values.mean():.2f}\n观测值标准差: {self.values.std():.2f}\n\n【插值结果】\n插值方法: RBF ({self.kernel_var.get()})\nEpsilon设置: {'自动优化' if self.epsilon_auto_var.get() else f'手动 ({self.epsilon_var.get():.3f})'}\n插值值范围: {grid.min():.2f} ~ {grid.max():.2f}\n插值值均值: {grid.mean():.2f}\n插值值标准差: {grid.std():.2f}\n\n【区域识别】\"\"\"\n            \n            if hasattr(self.interpolator, 'dense_mask') and self.interpolator.dense_mask is not None:\n                dense_count = np.sum(self.interpolator.dense_mask)\n                sparse_count = np.sum(self.interpolator.sparse_mask)\n                stats_text += f\"\"\"\n密集区域点数: {dense_count}\n稀疏区域点数: {sparse_count}\n密集/稀疏比例: {dense_count/sparse_count:.2f}\"\"\"\n            else:\n                stats_text += \"\\n未进行区域识别\"\n                \n            # 如果有交叉验证结果\n            try:\n                cv_scores = self.interpolator.cross_validate(self.coords, self.values, cv_folds=5)\n                stats_text += f\"\"\"\n\n【模型性能评估】\nR² (决定系数): {cv_scores['R2']:.4f} ± {cv_scores['R2_std']:.4f}\nRMSE (均方根误差): {cv_scores['RMSE']:.4f} ± {cv_scores['RMSE_std']:.4f}\nMAE (平均绝对误差): {cv_scores['MAE']:.4f} ± {cv_scores['MAE_std']:.4f}\"\"\"\n            except:\n                stats_text += \"\\n\\n【模型性能评估】\\n评估计算中...\"\n                \n            # 更新文本显示\n            self.stats_text.delete(1.0, tk.END)\n            self.stats_text.insert(1.0, stats_text)\n            \n        except Exception as e:\n            print(f\"更新统计信息失败: {e}\")\n            \n    def show_3d_result(self):\n        \"\"\"显示3D结果\"\"\"\n        if not self.reconstruction_result:\n            messagebox.showwarning(\"警告\", \"请先完成三维重建\")\n            return\n            \n        try:\n            self.status_var.set(\"正在准备3D显示...\")\n            \n            # 在新线程中显示3D结果，避免阻塞主界面\n            thread = Thread(target=self._show_3d_in_thread)\n            thread.daemon = True\n            thread.start()\n            \n        except Exception as e:\n            messagebox.showerror(\"错误\", f\"显示3D结果失败: {str(e)}\")\n            \n    def _show_3d_in_thread(self):\n        \"\"\"在线程中显示3D结果\"\"\"\n        try:\n            # 获取重建结果\n            grid = self.reconstruction_result['grid']\n            extent = self.reconstruction_result['extent']\n            resolution = self.reconstruction_result['resolution']\n            \n            # 创建PyVista网格\n            x = np.linspace(extent[0], extent[1], resolution[0])\n            y = np.linspace(extent[2], extent[3], resolution[1])\n            z = np.linspace(extent[4], extent[5], resolution[2])\n            \n            mesh = pv.StructuredGrid(*np.meshgrid(x, y, z, indexing='ij'))\n            mesh['values'] = grid.ravel(order='F')\n            \n            # 创建PyVista绘图器\n            plotter = pvqt.BackgroundPlotter(show=False, title=\"三维土体重建结果\")\n            \n            # 根据渲染模式显示\n            render_mode = self.render_mode_var.get()\n            \n            if render_mode == \"体积渲染\":\n                plotter.add_volume(mesh, scalars='values', opacity='linear')\n            elif render_mode == \"等值面\":\n                # 创建等值面\n                contours = mesh.contour(isosurfaces=5, scalars='values')\n                plotter.add_mesh(contours, scalars='values', opacity=0.7)\n            elif render_mode == \"切片\":\n                # 创建切片\n                slices = mesh.slice_orthogonal()\n                plotter.add_mesh(slices, scalars='values')\n            elif render_mode == \"轮廓\":\n                # 显示轮廓\n                edges = mesh.extract_all_edges()\n                plotter.add_mesh(edges, color='black', line_width=1)\n                plotter.add_mesh(mesh.outline(), color='red', line_width=3)\n                \n            # 添加钻孔点\n            if self.show_points_var.get():\n                points = pv.PolyData(self.coords)\n                points['values'] = self.values\n                plotter.add_mesh(points, scalars='values', point_size=10, \n                               render_points_as_spheres=True)\n                \n            # 设置相机和样式\n            plotter.add_axes()\n            plotter.add_scalar_bar(title='插值值')\n            plotter.set_background('white')\n            plotter.camera_position = 'iso'\n            \n            # 显示\n            plotter.show()\n            \n            self.status_var.set(\"3D显示完成\")\n            \n        except Exception as e:\n            print(f\"3D显示失败: {e}\")\n            self.status_var.set(\"3D显示失败\")\n            \n    def save_3d_screenshot(self):\n        \"\"\"保存3D截图\"\"\"\n        messagebox.showinfo(\"提示\", \"请在3D窗口中使用右键菜单保存截图\")\n        \n\ndef main():\n    \"\"\"主函数\"\"\"\n    root = tk.Tk()\n    app = SoilReconstructionGUI(root)\n    \n    try:\n        root.mainloop()\n    except KeyboardInterrupt:\n        print(\"\\n程序已退出\")\n    except Exception as e:\n        print(f\"程序运行错误: {e}\")\n        \nif __name__ == \"__main__\":\n    main()