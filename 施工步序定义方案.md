# 施工步序定义方案
**核心问题**: 施工步序在哪个模块定义？如何与可视化模块协作？

---

## 🏗️ **施工步序定义位置**

### **主要定义位置：计算模块 (Analysis Module)**
```
计算模块前处理 → 定义施工步序 → Kratos求解 → 可视化模块展示动画
```

### **施工步序数据流**
```
1. 用户在计算模块界面定义施工步序
2. 计算模块将步序配置传递给Kratos
3. Kratos按步序进行计算，输出每步结果
4. 可视化模块读取多步结果，生成施工过程动画
```

---

## 🎛️ **施工步序定义界面设计**

### **在计算模块中增加"施工序列"配置面板**

#### **基坑开挖施工步序示例**
```tsx
interface ConstructionStep {
  step_id: number;
  step_name: string;
  step_type: 'excavation' | 'support_install' | 'load_apply' | 'dewatering';
  duration: number;  // 施工周期（天）
  geometry_changes?: any;  // 几何变化
  load_changes?: any;      // 荷载变化
  boundary_changes?: any;  // 边界条件变化
  description: string;
}

// 施工步序配置组件
const ConstructionSequencePanel = () => {
  const [constructionSteps, setConstructionSteps] = useState<ConstructionStep[]>([
    {
      step_id: 1,
      step_name: "第一层开挖",
      step_type: "excavation",
      duration: 3,
      geometry_changes: {
        remove_volumes: ["excavation_layer_1"],
        excavation_depth: -2.0
      },
      description: "开挖至-2m标高"
    },
    {
      step_id: 2, 
      step_name: "第一道支撑安装",
      step_type: "support_install",
      duration: 2,
      geometry_changes: {
        add_elements: ["horizontal_strut_1"],
        support_stiffness: 2e8
      },
      description: "安装第一道水平支撑"
    },
    {
      step_id: 3,
      step_name: "第二层开挖", 
      step_type: "excavation",
      duration: 4,
      geometry_changes: {
        remove_volumes: ["excavation_layer_2"],
        excavation_depth: -4.5
      },
      description: "开挖至-4.5m标高"
    },
    {
      step_id: 4,
      step_name: "降水开始",
      step_type: "dewatering", 
      duration: 1,
      boundary_changes: {
        add_drainage_boundary: ["dewatering_wells"],
        target_water_level: -6.0
      },
      description: "启动降水井，水位降至-6m"
    }
  ]);

  return (
    <Card title="施工步序定义" size="small">
      <div style={{ marginBottom: 16 }}>
        <Button 
          type="dashed" 
          icon={<PlusOutlined />}
          onClick={() => addConstructionStep()}
          block
        >
          添加施工步
        </Button>
      </div>

      <List
        dataSource={constructionSteps}
        renderItem={(step, index) => (
          <List.Item>
            <Card 
              size="small" 
              title={`步骤${step.step_id}: ${step.step_name}`}
              extra={
                <Space>
                  <Button size="small" icon={<EditOutlined />} />
                  <Button size="small" icon={<DeleteOutlined />} danger />
                </Space>
              }
            >
              <Row gutter={16}>
                <Col span={6}>
                  <Text strong>类型:</Text>
                  <br />
                  <Tag color={getStepTypeColor(step.step_type)}>
                    {getStepTypeName(step.step_type)}
                  </Tag>
                </Col>
                <Col span={6}>
                  <Text strong>工期:</Text>
                  <br />
                  <Text>{step.duration} 天</Text>
                </Col>
                <Col span={12}>
                  <Text strong>描述:</Text>
                  <br />
                  <Text type="secondary">{step.description}</Text>
                </Col>
              </Row>
            </Card>
          </List.Item>
        )}
      />

      <Divider />
      
      <Space>
        <Button type="primary" icon={<PlayCircleOutlined />}>
          预览施工序列
        </Button>
        <Button icon={<SaveOutlined />}>
          保存配置
        </Button>
        <Button icon={<ImportOutlined />}>
          导入模板
        </Button>
      </Space>
    </Card>
  );
};
```

---

## 📐 **计算模块中的施工步序管理**

### **在计算模块路由中增加施工步序API**

```python
# gateway/modules/computation/construction_sequence.py

from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
from pydantic import BaseModel

router = APIRouter(prefix="/computation/construction-sequence")

class ConstructionStep(BaseModel):
    step_id: int
    step_name: str
    step_type: str  # excavation, support_install, load_apply, dewatering
    duration: float
    geometry_changes: Dict[str, Any] = {}
    load_changes: Dict[str, Any] = {}
    boundary_changes: Dict[str, Any] = {}
    description: str

class ConstructionSequence(BaseModel):
    project_id: str
    sequence_name: str
    total_steps: int
    total_duration: float
    steps: List[ConstructionStep]

@router.post("/create")
async def create_construction_sequence(sequence: ConstructionSequence):
    """创建施工步序配置"""
    try:
        # 验证步序逻辑合理性
        validate_construction_sequence(sequence)
        
        # 保存到数据库
        sequence_id = save_construction_sequence(sequence)
        
        return {
            "success": True,
            "sequence_id": sequence_id,
            "message": f"施工步序'{sequence.sequence_name}'创建成功"
        }
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/templates")
async def get_construction_templates():
    """获取施工步序模板"""
    templates = {
        "基坑开挖": {
            "description": "标准基坑分层开挖+支撑安装",
            "typical_steps": [
                "第一层开挖 → 第一道支撑 → 第二层开挖 → 第二道支撑 → 底板开挖"
            ],
            "duration": "15-25天"
        },
        "桩基施工": {
            "description": "钻孔灌注桩施工序列", 
            "typical_steps": [
                "钻孔 → 清孔 → 下钢筋笼 → 灌注混凝土 → 养护"
            ],
            "duration": "2-3天/桩"
        },
        "降水工程": {
            "description": "基坑降水施工序列",
            "typical_steps": [
                "降水井施工 → 试抽水 → 正式降水 → 水位监测"
            ],
            "duration": "7-10天"
        }
    }
    return {"templates": templates}

@router.post("/analyze")
async def analyze_construction_sequence(
    sequence_id: str,
    analysis_config: Dict[str, Any]
):
    """执行分步施工分析"""
    try:
        # 获取施工步序配置
        sequence = get_construction_sequence(sequence_id)
        
        # 初始化Kratos分析
        kratos_manager = get_kratos_manager()
        
        # 分步执行分析
        step_results = []
        for step in sequence.steps:
            # 根据步序类型配置分析参数
            step_config = configure_analysis_for_step(step, analysis_config)
            
            # 执行单步分析
            step_result = await kratos_manager.run_step_analysis(step_config)
            step_results.append(step_result)
            
            # 更新几何和边界条件为下一步做准备
            update_model_for_next_step(step)
        
        return {
            "success": True,
            "step_results": step_results,
            "message": "分步施工分析完成"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def configure_analysis_for_step(step: ConstructionStep, base_config: Dict):
    """根据施工步类型配置分析参数"""
    step_config = base_config.copy()
    
    if step.step_type == "excavation":
        # 开挖步：移除单元，更新荷载
        step_config.update({
            "remove_elements": step.geometry_changes.get("remove_volumes", []),
            "unloading_factor": 1.0,  # 完全卸荷
            "analysis_type": "nonlinear_static"
        })
        
    elif step.step_type == "support_install":
        # 支撑安装：添加单元，施加预应力
        step_config.update({
            "add_elements": step.geometry_changes.get("add_elements", []),
            "prestress": step.geometry_changes.get("prestress", 0),
            "analysis_type": "static_with_prestress"
        })
        
    elif step.step_type == "dewatering":
        # 降水步：修改边界条件，耦合分析
        step_config.update({
            "boundary_conditions": step.boundary_changes,
            "target_water_level": step.boundary_changes.get("target_water_level"),
            "analysis_type": "coupled_seepage_structural"
        })
    
    return step_config
```

---

## 🎬 **可视化模块中的施工动画**

### **在可视化模块中读取施工步序结果**

```tsx
// 在PostProcessingPanel中增加施工动画控制
const renderConstructionAnimation = () => (
  <Space direction="vertical" style={{ width: '100%' }}>
    <div>
      <Text strong>施工步序动画:</Text>
    </div>
    
    {/* 施工步序选择 */}
    <Select 
      value={selectedSequence}
      onChange={setSelectedSequence}
      placeholder="选择施工步序"
      style={{ width: '100%' }}
    >
      {availableSequences.map(seq => (
        <Option key={seq.id} value={seq.id}>
          {seq.name} ({seq.total_steps}步)
        </Option>
      ))}
    </Select>

    {/* 当前施工步显示 */}
    {currentConstructionStep && (
      <Card size="small" style={{ backgroundColor: '#f6ffed' }}>
        <Text strong>当前步骤: </Text>
        <Tag color="blue">步骤{currentConstructionStep.step_id}</Tag>
        <br />
        <Text>{currentConstructionStep.step_name}</Text>
        <br />
        <Text type="secondary">{currentConstructionStep.description}</Text>
      </Card>
    )}

    {/* 时间轴控制 */}
    <div>
      <Text>施工进度: 第{currentDay}天 / 共{totalDays}天</Text>
      <Slider
        min={0}
        max={totalDays}
        value={currentDay}
        onChange={setCurrentDay}
        tooltip={{ 
          formatter: (value) => `第${value}天: ${getCurrentStepName(value)}` 
        }}
      />
    </div>

    {/* 播放控制 */}
    <Row gutter={8}>
      <Col span={8}>
        <Button
          icon={constructionAnimation.playing ? <PauseOutlined /> : <PlayCircleOutlined />}
          onClick={toggleConstructionAnimation}
          block
          size="small"
        >
          {constructionAnimation.playing ? '暂停' : '播放'}
        </Button>
      </Col>
      <Col span={8}>
        <Button
          icon={<StepForwardOutlined />}
          onClick={nextConstructionStep}
          block
          size="small"
        >
          下一步
        </Button>
      </Col>
      <Col span={8}>
        <Button
          icon={<ReloadOutlined />}
          onClick={resetConstructionAnimation}
          block
          size="small"
        >
          重置
        </Button>
      </Col>
    </Row>

    {/* 施工步序时间线 */}
    <div>
      <Text strong>施工时间线:</Text>
      <Timeline size="small" style={{ marginTop: 8 }}>
        {constructionSteps.map((step, index) => (
          <Timeline.Item 
            key={step.step_id}
            color={index === currentStepIndex ? 'blue' : 'gray'}
            dot={index === currentStepIndex ? <PlayCircleOutlined /> : undefined}
          >
            <Text strong={index === currentStepIndex}>
              {step.step_name}
            </Text>
            <br />
            <Text type="secondary">
              第{getStepStartDay(step)}~{getStepEndDay(step)}天
            </Text>
          </Timeline.Item>
        ))}
      </Timeline>
    </div>
  </Space>
);

// 在主Tabs中增加施工动画Tab
<TabPane tab={<span><BuildOutlined />施工</span>} key="construction">
  {renderConstructionAnimation()}
</TabPane>
```

---

## 🔄 **数据流程图**

```
用户界面 (计算模块)
    ↓
定义施工步序 (ConstructionSequencePanel)
    ↓  
保存到数据库 (construction_sequence.py)
    ↓
Kratos分步计算 (kratos_handler.py)
    ↓
生成每步结果文件 (step_1.vtk, step_2.vtk, ...)
    ↓
可视化模块读取 (PyVistaViewer)
    ↓
生成施工过程动画 (PostProcessingPanel)
    ↓
用户查看施工模拟
```

---

## 📋 **总结**

**施工步序定义位置**: 
- **主要位置**: 计算模块的前处理阶段
- **配置界面**: ConstructionSequencePanel 
- **API接口**: `/computation/construction-sequence/*`
- **可视化**: PostProcessingPanel中的施工动画Tab

**优势**:
- 施工步序与分析逻辑紧密结合
- 可以预设常用施工模板
- 支持复杂的几何和边界条件变化
- 与现有可视化模块无缝集成

你觉得这个施工步序定义方案如何？