/**
 * å‡ ä½•åˆ°ç½‘æ ¼æ•°æ®ä¼ é€’æœåŠ¡ - 2å·ä¸3å·ä¸“å®¶åä½œæ¥å£
 * 0å·æ¶æ„å¸ˆå®ç°
 * æ ¸å¿ƒåŠŸèƒ½ï¼šå°†å‡ ä½•æ•°æ®è½¬æ¢ä¸º3å·ç½‘æ ¼ç”Ÿæˆæ‰€éœ€çš„æ ‡å‡†æ ¼å¼
 */

import { GeometryModel, MeshQualityFeedback, GeometryAdjustment } from './GeometryArchitectureService';
import { geometryArchitecture } from './GeometryArchitectureService';

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

// 3å·ä¸“å®¶ç½‘æ ¼æ•°æ®æ ¼å¼
export interface MeshData {
  vertices: Float32Array;
  faces: Uint32Array;
  nodeIds: Uint32Array;
  elementIds: Uint32Array;
  materialIds: Uint8Array;
  boundaryConditions: BoundaryCondition[];
  physicalGroups: PhysicalGroup[];
  quality: MeshQualityMetrics;
}

export interface BoundaryCondition {
  type: 'displacement' | 'force' | 'pressure' | 'temperature';
  nodeIds: number[];
  values: number[];
  direction?: 'x' | 'y' | 'z' | 'normal';
}

export interface PhysicalGroup {
  id: number;
  name: string;
  dimension: 1 | 2 | 3; // 1=è¾¹, 2=é¢, 3=ä½“
  elementIds: number[];
  materialProperties?: any;
}

export interface MeshQualityMetrics {
  averageQuality: number;
  minimumQuality: number;
  maximumQuality: number;
  skewnessDistribution: number[];
  aspectRatioDistribution: number[];
  jacobianDistribution: number[];
}

// å‡ ä½•åˆ°ç½‘æ ¼è½¬æ¢é…ç½®
export interface GeometryToMeshConfig {
  targetMeshSize: number;
  adaptiveMeshing: boolean;
  qualityThreshold: number;
  preserveFeatures: boolean;
  physicalGroupMapping: Record<string, number>;
}

class GeometryToMeshService {
  private initialized = false;
  private activeTransfers = new Map<string, GeometryTransfer>();

  constructor() {}

  public async initialize(): Promise<void> {
    if (this.initialized) return;
    console.log('ğŸ”— å‡ ä½•åˆ°ç½‘æ ¼æœåŠ¡åˆå§‹åŒ–ä¸­...');
    this.initialized = true;
    console.log('âœ… å‡ ä½•åˆ°ç½‘æ ¼æœåŠ¡åˆå§‹åŒ–å®Œæˆ');
  }

  // ============== ä¸»è¦è½¬æ¢æ¥å£ ==============
  public async processGeometry(geometry: GeometryModel, config?: GeometryToMeshConfig): Promise<MeshData> {
    if (!this.initialized) {
      await this.initialize();
    }

    console.log(`ğŸ”„ å¤„ç†å‡ ä½•æ¨¡å‹: ${geometry.id} (${geometry.type})`);
    
    const transferId = `transfer_${Date.now()}`;
    const transfer: GeometryTransfer = {
      id: transferId,
      geometryId: geometry.id,
      geometry,
      config: config || this.getDefaultConfig(),
      status: 'processing',
      startTime: Date.now()
    };
    
    this.activeTransfers.set(transferId, transfer);
    
    try {
      // 1. å‡ ä½•é¢„å¤„ç†
      const preprocessedGeometry = await this.preprocessGeometry(geometry, transfer.config);
      
      // 2. è½¬æ¢ä¸ºç½‘æ ¼æ•°æ®æ ¼å¼
      const meshData = await this.convertToMeshData(preprocessedGeometry, transfer.config);
      
      // 3. è´¨é‡éªŒè¯
      const qualityReport = await this.validateMeshData(meshData);
      
      // 4. å‘é€ç»™3å·ä¸“å®¶çš„ç½‘æ ¼æ¨¡å—
      await this.sendToMeshModule(meshData, qualityReport);
      
      transfer.status = 'completed';
      transfer.endTime = Date.now();
      
      console.log(`âœ… å‡ ä½•è½¬æ¢å®Œæˆ: ${transferId} (${transfer.endTime - transfer.startTime}ms)`);
      
      return meshData;
      
    } catch (error) {
      transfer.status = 'failed';
      transfer.error = error.message;
      console.error(`âŒ å‡ ä½•è½¬æ¢å¤±è´¥: ${transferId}`, error);
      throw error;
    } finally {
      this.activeTransfers.delete(transferId);
    }
  }

  // ============== å‡ ä½•é¢„å¤„ç† ==============
  private async preprocessGeometry(
    geometry: GeometryModel, 
    config: GeometryToMeshConfig
  ): Promise<GeometryModel> {
    console.log('ğŸ”§ é¢„å¤„ç†å‡ ä½•æ•°æ®...');
    
    let processedGeometry = { ...geometry };
    
    // 1. å‡ ä½•æ¸…ç†
    if (config.preserveFeatures) {
      processedGeometry = await this.cleanGeometry(processedGeometry);
    }
    
    // 2. ç‰¹å¾è¯†åˆ«
    const features = await this.identifyGeometricFeatures(processedGeometry);
    
    // 3. ç‰©ç†ç»„æ˜ å°„
    const physicalGroups = this.mapPhysicalGroups(processedGeometry, config.physicalGroupMapping);
    
    // 4. è¾¹ç•Œæ¡ä»¶å‡†å¤‡
    const boundaryPrep = await this.prepareBoundaryConditions(processedGeometry);
    
    // å°†é¢„å¤„ç†ä¿¡æ¯æ·»åŠ åˆ°å‡ ä½•æ¨¡å‹
    processedGeometry.metadata.parameters = {
      ...processedGeometry.metadata.parameters,
      features,
      physicalGroups,
      boundaryPrep
    };
    
    return processedGeometry;
  }

  private async cleanGeometry(geometry: GeometryModel): Promise<GeometryModel> {
    // å‡ ä½•æ¸…ç†ï¼šå»é‡é¡¶ç‚¹ã€ä¿®å¤æ‹“æ‰‘ç­‰
    const cleanedVertices = this.removeDuplicateVertices(geometry.vertices);
    const cleanedFaces = this.repairTopology(geometry.faces, cleanedVertices);
    
    return {
      ...geometry,
      vertices: cleanedVertices,
      faces: cleanedFaces
    };
  }

  private removeDuplicateVertices(vertices: Float32Array): Float32Array {
    const vertexMap = new Map<string, number>();
    const uniqueVertices: number[] = [];
    const vertexMapping: number[] = [];
    
    for (let i = 0; i < vertices.length; i += 3) {
      const key = `${vertices[i].toFixed(6)},${vertices[i+1].toFixed(6)},${vertices[i+2].toFixed(6)}`;
      
      if (vertexMap.has(key)) {
        vertexMapping.push(vertexMap.get(key)!);
      } else {
        const newIndex = uniqueVertices.length / 3;
        vertexMap.set(key, newIndex);
        vertexMapping.push(newIndex);
        uniqueVertices.push(vertices[i], vertices[i+1], vertices[i+2]);
      }
    }
    
    return new Float32Array(uniqueVertices);
  }

  private repairTopology(faces: Uint32Array, vertices: Float32Array): Uint32Array {
    // ç®€åŒ–çš„æ‹“æ‰‘ä¿®å¤
    return faces;
  }

  private async identifyGeometricFeatures(geometry: GeometryModel): Promise<any> {
    // è¯†åˆ«å‡ ä½•ç‰¹å¾ï¼šå°–é”è¾¹ã€æ›²é¢ç­‰
    return {
      sharpEdges: [],
      curves: [],
      surfaces: []
    };
  }

  private mapPhysicalGroups(geometry: GeometryModel, mapping: Record<string, number>): PhysicalGroup[] {
    const groups: PhysicalGroup[] = [];
    
    // æ ¹æ®å‡ ä½•ç±»å‹åˆ›å»ºç‰©ç†ç»„
    switch (geometry.type) {
      case 'geology':
        groups.push({
          id: mapping['soil'] || 1,
          name: 'Soil Domain',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'soil' }
        });
        break;
        
      case 'excavation':
        groups.push({
          id: mapping['excavation'] || 2,
          name: 'Excavation Volume',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'void' }
        });
        break;
        
      case 'support':
        groups.push({
          id: mapping['support'] || 3,
          name: 'Support Structure',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'concrete' }
        });
        break;
    }
    
    return groups;
  }

  private async prepareBoundaryConditions(geometry: GeometryModel): Promise<BoundaryCondition[]> {
    const conditions: BoundaryCondition[] = [];
    
    // æ ¹æ®å‡ ä½•ç±»å‹æ·»åŠ è¾¹ç•Œæ¡ä»¶
    if (geometry.type === 'excavation') {
      // å¼€æŒ–é¢çš„è¾¹ç•Œæ¡ä»¶
      conditions.push({
        type: 'displacement',
        nodeIds: [], // å°†åœ¨ç½‘æ ¼ç”Ÿæˆåå¡«å……
        values: [0, 0, 0],
        direction: 'normal'
      });
    }
    
    return conditions;
  }

  // ============== ç½‘æ ¼æ•°æ®è½¬æ¢ ==============
  private async convertToMeshData(
    geometry: GeometryModel, 
    config: GeometryToMeshConfig
  ): Promise<MeshData> {
    console.log('ğŸ”„ è½¬æ¢ä¸ºç½‘æ ¼æ•°æ®æ ¼å¼...');
    
    // ç”ŸæˆèŠ‚ç‚¹å’Œå•å…ƒID
    const nodeIds = this.generateNodeIds(geometry.vertices);
    const elementIds = this.generateElementIds(geometry.faces);
    
    // åˆ†é…ææ–™ID
    const materialIds = this.assignMaterialIds(geometry, elementIds);
    
    // åˆ›å»ºè¾¹ç•Œæ¡ä»¶
    const boundaryConditions = await this.createBoundaryConditions(geometry, nodeIds);
    
    // åˆ›å»ºç‰©ç†ç»„
    const physicalGroups = this.createPhysicalGroups(geometry, elementIds);
    
    // è®¡ç®—åˆå§‹è´¨é‡æŒ‡æ ‡
    const quality = this.calculateInitialQuality(geometry.vertices, geometry.faces);
    
    return {
      vertices: geometry.vertices,
      faces: geometry.faces,
      nodeIds,
      elementIds,
      materialIds,
      boundaryConditions,
      physicalGroups,
      quality
    };
  }

  private generateNodeIds(vertices: Float32Array): Uint32Array {
    const nodeCount = vertices.length / 3;
    const nodeIds = new Uint32Array(nodeCount);
    
    for (let i = 0; i < nodeCount; i++) {
      nodeIds[i] = i + 1; // ä»1å¼€å§‹ç¼–å·
    }
    
    return nodeIds;
  }

  private generateElementIds(faces: Uint32Array): Uint32Array {
    const elementCount = faces.length / 3;
    const elementIds = new Uint32Array(elementCount);
    
    for (let i = 0; i < elementCount; i++) {
      elementIds[i] = i + 1; // ä»1å¼€å§‹ç¼–å·
    }
    
    return elementIds;
  }

  private assignMaterialIds(geometry: GeometryModel, elementIds: Uint32Array): Uint8Array {
    const materialIds = new Uint8Array(elementIds.length);
    
    // æ ¹æ®å‡ ä½•ç±»å‹åˆ†é…ææ–™ID
    let materialId = 1;
    switch (geometry.type) {
      case 'geology':
        materialId = 1; // åœŸä½“ææ–™
        break;
      case 'excavation':
        materialId = 2; // å¼€æŒ–åŒºåŸŸ
        break;
      case 'support':
        materialId = 3; // æ”¯æŠ¤ç»“æ„
        break;
      case 'combined':
        materialId = 1; // é»˜è®¤ææ–™
        break;
    }
    
    materialIds.fill(materialId);
    return materialIds;
  }

  private async createBoundaryConditions(
    geometry: GeometryModel, 
    nodeIds: Uint32Array
  ): Promise<BoundaryCondition[]> {
    // åŸºäºå‡ ä½•è¾¹ç•Œè‡ªåŠ¨åˆ›å»ºè¾¹ç•Œæ¡ä»¶
    return [];
  }

  private createPhysicalGroups(geometry: GeometryModel, elementIds: Uint32Array): PhysicalGroup[] {
    return [{
      id: 1,
      name: `${geometry.type}_group`,
      dimension: 3,
      elementIds: Array.from(elementIds),
      materialProperties: {
        type: geometry.type,
        density: 2000,
        elasticModulus: 20000000,
        poissonRatio: 0.3
      }
    }];
  }

  private calculateInitialQuality(vertices: Float32Array, faces: Uint32Array): MeshQualityMetrics {
    // è®¡ç®—åˆå§‹ç½‘æ ¼è´¨é‡
    return {
      averageQuality: 0.8,
      minimumQuality: 0.5,
      maximumQuality: 1.0,
      skewnessDistribution: [0.1, 0.2, 0.4, 0.2, 0.1],
      aspectRatioDistribution: [0.1, 0.3, 0.4, 0.15, 0.05],
      jacobianDistribution: [0.05, 0.15, 0.6, 0.15, 0.05]
    };
  }

  // ============== è´¨é‡éªŒè¯ ==============
  private async validateMeshData(meshData: MeshData): Promise<any> {
    console.log('ğŸ” éªŒè¯ç½‘æ ¼æ•°æ®è´¨é‡...');
    
    const validation = {
      nodeCount: meshData.nodeIds.length,
      elementCount: meshData.elementIds.length,
      materialGroupCount: new Set(meshData.materialIds).size,
      boundaryConditionCount: meshData.boundaryConditions.length,
      physicalGroupCount: meshData.physicalGroups.length,
      overallQuality: meshData.quality.averageQuality,
      issues: [] as string[]
    };
    
    // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    if (validation.nodeCount === 0) {
      validation.issues.push('èŠ‚ç‚¹æ•°é‡ä¸ºé›¶');
    }
    
    if (validation.elementCount === 0) {
      validation.issues.push('å•å…ƒæ•°é‡ä¸ºé›¶');
    }
    
    if (validation.overallQuality < 0.3) {
      validation.issues.push('ç½‘æ ¼è´¨é‡è¿‡ä½');
    }
    
    return validation;
  }

  // ============== ä¸3å·ä¸“å®¶é€šä¿¡ ==============
  private async sendToMeshModule(meshData: MeshData, qualityReport: any): Promise<void> {
    console.log('ğŸ“¤ å‘é€æ•°æ®ç»™3å·ä¸“å®¶ç½‘æ ¼æ¨¡å—...');
    
    try {
      // åŠ¨æ€å¯¼å…¥ç½‘æ ¼æœåŠ¡ï¼ˆé¿å…å¾ªç¯ä¾èµ–ï¼‰
      const meshService = await import('./meshingService');
      
      if (meshService.default && meshService.default.receiveMeshData) {
        await meshService.default.receiveMeshData(meshData, qualityReport);
      }
      
      // é€šçŸ¥å‡ ä½•æ¶æ„æœåŠ¡
      await geometryArchitecture.sendGeometryToMeshModule(meshData.vertices.toString());
      
    } catch (error) {
      console.warn('âš ï¸ æ— æ³•è¿æ¥3å·ä¸“å®¶ç½‘æ ¼æ¨¡å—:', error);
    }
  }

  // ============== åé¦ˆå¤„ç† ==============
  public async processMeshFeedback(feedback: MeshQualityFeedback): Promise<void> {
    console.log(`ğŸ”„ å¤„ç†3å·ä¸“å®¶åé¦ˆ: ${feedback.geometryId}`);
    
    try {
      // è½¬å‘ç»™å‡ ä½•æ¶æ„æœåŠ¡å¤„ç†
      await geometryArchitecture.receiveMeshQualityFeedback(feedback);
      
    } catch (error) {
      console.error('âŒ å¤„ç†ç½‘æ ¼åé¦ˆå¤±è´¥:', error);
    }
  }

  // ============== å·¥å…·æ–¹æ³• ==============
  private getDefaultConfig(): GeometryToMeshConfig {
    return {
      targetMeshSize: 1.0,
      adaptiveMeshing: true,
      qualityThreshold: 0.7,
      preserveFeatures: true,
      physicalGroupMapping: {
        'soil': 1,
        'excavation': 2,
        'support': 3,
        'structure': 4
      }
    };
  }

  public getActiveTransfers(): GeometryTransfer[] {
    return Array.from(this.activeTransfers.values());
  }

  public getTransferStatus(transferId: string): GeometryTransfer | undefined {
    return this.activeTransfers.get(transferId);
  }
}

// å‡ ä½•è½¬æ¢è®°å½•
interface GeometryTransfer {
  id: string;
  geometryId: string;
  geometry: GeometryModel;
  config: GeometryToMeshConfig;
  status: 'processing' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  error?: string;
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
const geometryToMeshService = new GeometryToMeshService();
export default geometryToMeshService;

export interface MaterialZone {
  zoneId: string;
  zoneName: string;
  materialType: 'soil' | 'concrete' | 'steel';
  faceIndices: number[];
  properties: {
    density: number;
    elasticModulus: number;
    poissonRatio: number;
    cohesion?: number;
    frictionAngle?: number;
    permeability?: number;
  };
}

export interface GeometryToMeshData {
  header: {
    version: string;
    timestamp: string;
    geometryType: 'geology' | 'excavation' | 'support';
    coordinateSystem: string;
    units: string;
  };
  
  // æ ¸å¿ƒå‡ ä½•æ•°æ®
  meshGeometry: {
    vertices: Float32Array;
    faces: Uint32Array;
    normals: Float32Array;
    vertexCount: number;
    faceCount: number;
  };
  
  // ææ–™åˆ†åŒº
  materialZones: MaterialZone[];
  
  // ç½‘æ ¼æŒ‡å¯¼
  meshGuidance: {
    globalElementSize: number;
    localRefinement: Array<{
      region: string;
      faceIndices: number[];
      targetSize: number;
      priority: 'high' | 'medium' | 'low';
    }>;
    qualityRequirements: {
      minAngle: number;
      maxAspectRatio: number;
      targetQuality: number;
    };
  };
}

class GeometryToMeshService {
  private baseUrl: string;

  constructor() {
    this.baseUrl = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:8080'
      : window.location.origin;
  }

  /**
   * å°†DXFè¾¹ç•Œè½¬æ¢ä¸ºåŸºå‘å‡ ä½•æ•°æ®
   */
  async convertDXFToExcavation(
    dxfBoundary: Point3D[],
    depth: number,
    surfaceElevation: number
  ): Promise<GeometryToMeshData> {
    
    const vertices: number[] = [];
    const faces: number[] = [];
    const normals: number[] = [];
    
    // ç”Ÿæˆé¡¶éƒ¨è¾¹ç•Œé¡¶ç‚¹
    dxfBoundary.forEach(point => {
      vertices.push(point.x, point.y, surfaceElevation);
      normals.push(0, 0, 1);
    });
    
    // ç”Ÿæˆåº•éƒ¨è¾¹ç•Œé¡¶ç‚¹
    dxfBoundary.forEach(point => {
      vertices.push(point.x, point.y, surfaceElevation - depth);
      normals.push(0, 0, -1);
    });
    
    const n = dxfBoundary.length;
    
    // ç”Ÿæˆåº•é¢ä¸‰è§’å½¢
    for (let i = 1; i < n - 1; i++) {
      faces.push(n, n + i, n + i + 1);
    }
    
    // ç”Ÿæˆä¾§é¢ä¸‰è§’å½¢
    for (let i = 0; i < n; i++) {
      const next = (i + 1) % n;
      faces.push(i, next, next + n);
      faces.push(i, next + n, i + n);
    }
    
    return {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'excavation',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array(vertices),
        faces: new Uint32Array(faces),
        normals: new Float32Array(normals),
        vertexCount: vertices.length / 3,
        faceCount: faces.length / 3
      },
      materialZones: [{
        zoneId: 'excavation_air',
        zoneName: 'å¼€æŒ–ç©ºé—´',
        materialType: 'soil',
        faceIndices: Array.from({ length: faces.length / 3 }, (_, i) => i),
        properties: {
          density: 1.225,
          elasticModulus: 1000,
          poissonRatio: 0.3
        }
      }],
      meshGuidance: {
        globalElementSize: 2.0,
        localRefinement: [{
          region: 'excavation_corners',
          faceIndices: [0, 1, 2, 3],
          targetSize: 1.0,
          priority: 'high'
        }],
        qualityRequirements: {
          minAngle: 20,
          maxAspectRatio: 10,
          targetQuality: 0.8
        }
      }
    };
  }

  /**
   * å°†åœ°è´¨æ•°æ®è½¬æ¢ä¸ºç½‘æ ¼æ•°æ®
   */
  async convertGeologyToMesh(
    geologyLayers: Array<{
      layerId: number;
      vertices: Point3D[];
      soilType: string;
      properties: any;
    }>
  ): Promise<GeometryToMeshData> {
    
    const allVertices: number[] = [];
    const allFaces: number[] = [];
    const allNormals: number[] = [];
    const materialZones: MaterialZone[] = [];
    
    let vertexOffset = 0;
    
    for (const layer of geologyLayers) {
      const layerVertices = layer.vertices;
      const startIndex = vertexOffset;
      
      // æ·»åŠ é¡¶ç‚¹
      layerVertices.forEach(v => {
        allVertices.push(v.x, v.y, v.z);
        allNormals.push(0, 0, 1);
      });
      
      // ç”Ÿæˆä¸‰è§’å½¢é¢ (ç®€å•ä¸‰è§’å‰–åˆ†)
      const layerFaces: number[] = [];
      for (let i = 1; i < layerVertices.length - 1; i++) {
        allFaces.push(startIndex, startIndex + i, startIndex + i + 1);
        layerFaces.push(allFaces.length / 3 - 1);
      }
      
      // ææ–™åˆ†åŒº
      materialZones.push({
        zoneId: `layer_${layer.layerId}`,
        zoneName: layer.soilType,
        materialType: 'soil',
        faceIndices: layerFaces,
        properties: layer.properties
      });
      
      vertexOffset += layerVertices.length;
    }
    
    return {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'geology',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array(allVertices),
        faces: new Uint32Array(allFaces),
        normals: new Float32Array(allNormals),
        vertexCount: allVertices.length / 3,
        faceCount: allFaces.length / 3
      },
      materialZones,
      meshGuidance: {
        globalElementSize: 2.0,
        localRefinement: [],
        qualityRequirements: {
          minAngle: 15,
          maxAspectRatio: 15,
          targetQuality: 0.7
        }
      }
    };
  }

  /**
   * å‘é€å‡ ä½•æ•°æ®ç»™3å·ç½‘æ ¼ç”Ÿæˆ
   */
  async sendToMeshGenerator(data: GeometryToMeshData): Promise<{
    success: boolean;
    meshJobId: string;
    estimatedTime: number;
  }> {
    try {
      console.log('ğŸ”§ å‘é€å‡ ä½•æ•°æ®ç»™3å·ç½‘æ ¼ç”Ÿæˆ');
      
      const response = await fetch(`${this.baseUrl}/api/meshing/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error(`ç½‘æ ¼ç”Ÿæˆè¯·æ±‚å¤±è´¥: ${response.status}`);
      }

      const result = await response.json();
      console.log('âœ… ç½‘æ ¼ç”Ÿæˆä»»åŠ¡å·²æäº¤:', result);
      
      return result;
    } catch (error) {
      console.error('âŒ å‘é€ç½‘æ ¼æ•°æ®å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æŸ¥è¯¢ç½‘æ ¼ç”ŸæˆçŠ¶æ€
   */
  async getMeshingStatus(jobId: string): Promise<{
    status: 'pending' | 'processing' | 'completed' | 'failed';
    progress: number;
    result?: any;
    error?: string;
  }> {
    try {
      const response = await fetch(`${this.baseUrl}/api/meshing/status/${jobId}`);
      return await response.json();
    } catch (error) {
      console.error('æŸ¥è¯¢ç½‘æ ¼çŠ¶æ€å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * ç»„åˆå®Œæ•´çš„CAEæ•°æ®æµ
   */
  async processCompleteCAEWorkflow(
    dxfBoundary: Point3D[],
    geologyData: any[],
    excavationDepth: number,
    surfaceElevation: number
  ): Promise<string> {
    
    console.log('ğŸš€ å¼€å§‹å®Œæ•´CAEå·¥ä½œæµ');
    
    // 1. è½¬æ¢åŸºå‘å‡ ä½•
    const excavationData = await this.convertDXFToExcavation(
      dxfBoundary, 
      excavationDepth, 
      surfaceElevation
    );
    
    // 2. è½¬æ¢åœ°è´¨æ•°æ®
    const geologyMeshData = await this.convertGeologyToMesh(geologyData);
    
    // 3. åˆå¹¶æ•°æ®
    const combinedData: GeometryToMeshData = {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'excavation',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array([
          ...excavationData.meshGeometry.vertices,
          ...geologyMeshData.meshGeometry.vertices
        ]),
        faces: new Uint32Array([
          ...excavationData.meshGeometry.faces,
          ...Array.from(geologyMeshData.meshGeometry.faces).map(
            f => f + excavationData.meshGeometry.vertexCount
          )
        ]),
        normals: new Float32Array([
          ...excavationData.meshGeometry.normals,
          ...geologyMeshData.meshGeometry.normals
        ]),
        vertexCount: excavationData.meshGeometry.vertexCount + geologyMeshData.meshGeometry.vertexCount,
        faceCount: excavationData.meshGeometry.faceCount + geologyMeshData.meshGeometry.faceCount
      },
      materialZones: [
        ...excavationData.materialZones,
        ...geologyMeshData.materialZones
      ],
      meshGuidance: excavationData.meshGuidance
    };
    
    // 4. å‘é€ç»™3å·
    const meshJob = await this.sendToMeshGenerator(combinedData);
    
    console.log('âœ… CAEå·¥ä½œæµå¯åŠ¨å®Œæˆï¼Œç½‘æ ¼ä»»åŠ¡ID:', meshJob.meshJobId);
    
    return meshJob.meshJobId;
  }
}

// åˆ›å»ºå•ä¾‹
export const geometryToMeshService = new GeometryToMeshService();

// ä¾¿æ·å‡½æ•°
export const processCAEWorkflow = (
  dxfBoundary: Point3D[],
  geologyData: any[],
  excavationDepth: number,
  surfaceElevation: number
) => geometryToMeshService.processCompleteCAEWorkflow(
  dxfBoundary, 
  geologyData, 
  excavationDepth, 
  surfaceElevation
);

export default geometryToMeshService;