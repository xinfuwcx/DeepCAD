/**
 * 几何到网格数据传递服务 - 2号与3号专家协作接口
 * 0号架构师实现
 * 核心功能：将几何数据转换为3号网格生成所需的标准格式
 */

import { GeometryModel, MeshQualityFeedback, GeometryAdjustment } from './GeometryArchitectureService';
import { geometryArchitecture } from './GeometryArchitectureService';

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

// 3号专家网格数据格式
export interface MeshData {
  vertices: Float32Array;
  faces: Uint32Array;
  nodeIds: Uint32Array;
  elementIds: Uint32Array;
  materialIds: Uint8Array;
  boundaryConditions: BoundaryCondition[];
  physicalGroups: PhysicalGroup[];
  quality: MeshQualityMetrics;
}

export interface BoundaryCondition {
  type: 'displacement' | 'force' | 'pressure' | 'temperature';
  nodeIds: number[];
  values: number[];
  direction?: 'x' | 'y' | 'z' | 'normal';
}

export interface PhysicalGroup {
  id: number;
  name: string;
  dimension: 1 | 2 | 3; // 1=边, 2=面, 3=体
  elementIds: number[];
  materialProperties?: any;
}

export interface MeshQualityMetrics {
  averageQuality: number;
  minimumQuality: number;
  maximumQuality: number;
  skewnessDistribution: number[];
  aspectRatioDistribution: number[];
  jacobianDistribution: number[];
}

// 几何到网格转换配置
export interface GeometryToMeshConfig {
  targetMeshSize: number;
  adaptiveMeshing: boolean;
  qualityThreshold: number;
  preserveFeatures: boolean;
  physicalGroupMapping: Record<string, number>;
}

class GeometryToMeshService {
  private initialized = false;
  private activeTransfers = new Map<string, GeometryTransfer>();

  constructor() {}

  public async initialize(): Promise<void> {
    if (this.initialized) return;
    console.log('🔗 几何到网格服务初始化中...');
    this.initialized = true;
    console.log('✅ 几何到网格服务初始化完成');
  }

  // ============== 主要转换接口 ==============
  public async processGeometry(geometry: GeometryModel, config?: GeometryToMeshConfig): Promise<MeshData> {
    if (!this.initialized) {
      await this.initialize();
    }

    console.log(`🔄 处理几何模型: ${geometry.id} (${geometry.type})`);
    
    const transferId = `transfer_${Date.now()}`;
    const transfer: GeometryTransfer = {
      id: transferId,
      geometryId: geometry.id,
      geometry,
      config: config || this.getDefaultConfig(),
      status: 'processing',
      startTime: Date.now()
    };
    
    this.activeTransfers.set(transferId, transfer);
    
    try {
      // 1. 几何预处理
      const preprocessedGeometry = await this.preprocessGeometry(geometry, transfer.config);
      
      // 2. 转换为网格数据格式
      const meshData = await this.convertToMeshData(preprocessedGeometry, transfer.config);
      
      // 3. 质量验证
      const qualityReport = await this.validateMeshData(meshData);
      
      // 4. 发送给3号专家的网格模块
      await this.sendToMeshModule(meshData, qualityReport);
      
      transfer.status = 'completed';
      transfer.endTime = Date.now();
      
      console.log(`✅ 几何转换完成: ${transferId} (${transfer.endTime - transfer.startTime}ms)`);
      
      return meshData;
      
    } catch (error) {
      transfer.status = 'failed';
      transfer.error = error.message;
      console.error(`❌ 几何转换失败: ${transferId}`, error);
      throw error;
    } finally {
      this.activeTransfers.delete(transferId);
    }
  }

  // ============== 几何预处理 ==============
  private async preprocessGeometry(
    geometry: GeometryModel, 
    config: GeometryToMeshConfig
  ): Promise<GeometryModel> {
    console.log('🔧 预处理几何数据...');
    
    let processedGeometry = { ...geometry };
    
    // 1. 几何清理
    if (config.preserveFeatures) {
      processedGeometry = await this.cleanGeometry(processedGeometry);
    }
    
    // 2. 特征识别
    const features = await this.identifyGeometricFeatures(processedGeometry);
    
    // 3. 物理组映射
    const physicalGroups = this.mapPhysicalGroups(processedGeometry, config.physicalGroupMapping);
    
    // 4. 边界条件准备
    const boundaryPrep = await this.prepareBoundaryConditions(processedGeometry);
    
    // 将预处理信息添加到几何模型
    processedGeometry.metadata.parameters = {
      ...processedGeometry.metadata.parameters,
      features,
      physicalGroups,
      boundaryPrep
    };
    
    return processedGeometry;
  }

  private async cleanGeometry(geometry: GeometryModel): Promise<GeometryModel> {
    // 几何清理：去重顶点、修复拓扑等
    const cleanedVertices = this.removeDuplicateVertices(geometry.vertices);
    const cleanedFaces = this.repairTopology(geometry.faces, cleanedVertices);
    
    return {
      ...geometry,
      vertices: cleanedVertices,
      faces: cleanedFaces
    };
  }

  private removeDuplicateVertices(vertices: Float32Array): Float32Array {
    const vertexMap = new Map<string, number>();
    const uniqueVertices: number[] = [];
    const vertexMapping: number[] = [];
    
    for (let i = 0; i < vertices.length; i += 3) {
      const key = `${vertices[i].toFixed(6)},${vertices[i+1].toFixed(6)},${vertices[i+2].toFixed(6)}`;
      
      if (vertexMap.has(key)) {
        vertexMapping.push(vertexMap.get(key)!);
      } else {
        const newIndex = uniqueVertices.length / 3;
        vertexMap.set(key, newIndex);
        vertexMapping.push(newIndex);
        uniqueVertices.push(vertices[i], vertices[i+1], vertices[i+2]);
      }
    }
    
    return new Float32Array(uniqueVertices);
  }

  private repairTopology(faces: Uint32Array, vertices: Float32Array): Uint32Array {
    // 简化的拓扑修复
    return faces;
  }

  private async identifyGeometricFeatures(geometry: GeometryModel): Promise<any> {
    // 识别几何特征：尖锐边、曲面等
    return {
      sharpEdges: [],
      curves: [],
      surfaces: []
    };
  }

  private mapPhysicalGroups(geometry: GeometryModel, mapping: Record<string, number>): PhysicalGroup[] {
    const groups: PhysicalGroup[] = [];
    
    // 根据几何类型创建物理组
    switch (geometry.type) {
      case 'geology':
        groups.push({
          id: mapping['soil'] || 1,
          name: 'Soil Domain',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'soil' }
        });
        break;
        
      case 'excavation':
        groups.push({
          id: mapping['excavation'] || 2,
          name: 'Excavation Volume',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'void' }
        });
        break;
        
      case 'support':
        groups.push({
          id: mapping['support'] || 3,
          name: 'Support Structure',
          dimension: 3,
          elementIds: [],
          materialProperties: { type: 'concrete' }
        });
        break;
    }
    
    return groups;
  }

  private async prepareBoundaryConditions(geometry: GeometryModel): Promise<BoundaryCondition[]> {
    const conditions: BoundaryCondition[] = [];
    
    // 根据几何类型添加边界条件
    if (geometry.type === 'excavation') {
      // 开挖面的边界条件
      conditions.push({
        type: 'displacement',
        nodeIds: [], // 将在网格生成后填充
        values: [0, 0, 0],
        direction: 'normal'
      });
    }
    
    return conditions;
  }

  // ============== 网格数据转换 ==============
  private async convertToMeshData(
    geometry: GeometryModel, 
    config: GeometryToMeshConfig
  ): Promise<MeshData> {
    console.log('🔄 转换为网格数据格式...');
    
    // 生成节点和单元ID
    const nodeIds = this.generateNodeIds(geometry.vertices);
    const elementIds = this.generateElementIds(geometry.faces);
    
    // 分配材料ID
    const materialIds = this.assignMaterialIds(geometry, elementIds);
    
    // 创建边界条件
    const boundaryConditions = await this.createBoundaryConditions(geometry, nodeIds);
    
    // 创建物理组
    const physicalGroups = this.createPhysicalGroups(geometry, elementIds);
    
    // 计算初始质量指标
    const quality = this.calculateInitialQuality(geometry.vertices, geometry.faces);
    
    return {
      vertices: geometry.vertices,
      faces: geometry.faces,
      nodeIds,
      elementIds,
      materialIds,
      boundaryConditions,
      physicalGroups,
      quality
    };
  }

  private generateNodeIds(vertices: Float32Array): Uint32Array {
    const nodeCount = vertices.length / 3;
    const nodeIds = new Uint32Array(nodeCount);
    
    for (let i = 0; i < nodeCount; i++) {
      nodeIds[i] = i + 1; // 从1开始编号
    }
    
    return nodeIds;
  }

  private generateElementIds(faces: Uint32Array): Uint32Array {
    const elementCount = faces.length / 3;
    const elementIds = new Uint32Array(elementCount);
    
    for (let i = 0; i < elementCount; i++) {
      elementIds[i] = i + 1; // 从1开始编号
    }
    
    return elementIds;
  }

  private assignMaterialIds(geometry: GeometryModel, elementIds: Uint32Array): Uint8Array {
    const materialIds = new Uint8Array(elementIds.length);
    
    // 根据几何类型分配材料ID
    let materialId = 1;
    switch (geometry.type) {
      case 'geology':
        materialId = 1; // 土体材料
        break;
      case 'excavation':
        materialId = 2; // 开挖区域
        break;
      case 'support':
        materialId = 3; // 支护结构
        break;
      case 'combined':
        materialId = 1; // 默认材料
        break;
    }
    
    materialIds.fill(materialId);
    return materialIds;
  }

  private async createBoundaryConditions(
    geometry: GeometryModel, 
    nodeIds: Uint32Array
  ): Promise<BoundaryCondition[]> {
    // 基于几何边界自动创建边界条件
    return [];
  }

  private createPhysicalGroups(geometry: GeometryModel, elementIds: Uint32Array): PhysicalGroup[] {
    return [{
      id: 1,
      name: `${geometry.type}_group`,
      dimension: 3,
      elementIds: Array.from(elementIds),
      materialProperties: {
        type: geometry.type,
        density: 2000,
        elasticModulus: 20000000,
        poissonRatio: 0.3
      }
    }];
  }

  private calculateInitialQuality(vertices: Float32Array, faces: Uint32Array): MeshQualityMetrics {
    // 计算初始网格质量
    return {
      averageQuality: 0.8,
      minimumQuality: 0.5,
      maximumQuality: 1.0,
      skewnessDistribution: [0.1, 0.2, 0.4, 0.2, 0.1],
      aspectRatioDistribution: [0.1, 0.3, 0.4, 0.15, 0.05],
      jacobianDistribution: [0.05, 0.15, 0.6, 0.15, 0.05]
    };
  }

  // ============== 质量验证 ==============
  private async validateMeshData(meshData: MeshData): Promise<any> {
    console.log('🔍 验证网格数据质量...');
    
    const validation = {
      nodeCount: meshData.nodeIds.length,
      elementCount: meshData.elementIds.length,
      materialGroupCount: new Set(meshData.materialIds).size,
      boundaryConditionCount: meshData.boundaryConditions.length,
      physicalGroupCount: meshData.physicalGroups.length,
      overallQuality: meshData.quality.averageQuality,
      issues: [] as string[]
    };
    
    // 检查数据完整性
    if (validation.nodeCount === 0) {
      validation.issues.push('节点数量为零');
    }
    
    if (validation.elementCount === 0) {
      validation.issues.push('单元数量为零');
    }
    
    if (validation.overallQuality < 0.3) {
      validation.issues.push('网格质量过低');
    }
    
    return validation;
  }

  // ============== 与3号专家通信 ==============
  private async sendToMeshModule(meshData: MeshData, qualityReport: any): Promise<void> {
    console.log('📤 发送数据给3号专家网格模块...');
    
    try {
      // 动态导入网格服务（避免循环依赖）
      const meshService = await import('./meshingService');
      
      if (meshService.default && meshService.default.receiveMeshData) {
        await meshService.default.receiveMeshData(meshData, qualityReport);
      }
      
      // 通知几何架构服务
      await geometryArchitecture.sendGeometryToMeshModule(meshData.vertices.toString());
      
    } catch (error) {
      console.warn('⚠️ 无法连接3号专家网格模块:', error);
    }
  }

  // ============== 反馈处理 ==============
  public async processMeshFeedback(feedback: MeshQualityFeedback): Promise<void> {
    console.log(`🔄 处理3号专家反馈: ${feedback.geometryId}`);
    
    try {
      // 转发给几何架构服务处理
      await geometryArchitecture.receiveMeshQualityFeedback(feedback);
      
    } catch (error) {
      console.error('❌ 处理网格反馈失败:', error);
    }
  }

  // ============== 工具方法 ==============
  private getDefaultConfig(): GeometryToMeshConfig {
    return {
      targetMeshSize: 1.0,
      adaptiveMeshing: true,
      qualityThreshold: 0.7,
      preserveFeatures: true,
      physicalGroupMapping: {
        'soil': 1,
        'excavation': 2,
        'support': 3,
        'structure': 4
      }
    };
  }

  public getActiveTransfers(): GeometryTransfer[] {
    return Array.from(this.activeTransfers.values());
  }

  public getTransferStatus(transferId: string): GeometryTransfer | undefined {
    return this.activeTransfers.get(transferId);
  }
}

// 几何转换记录
interface GeometryTransfer {
  id: string;
  geometryId: string;
  geometry: GeometryModel;
  config: GeometryToMeshConfig;
  status: 'processing' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  error?: string;
}

// 导出单例实例
const geometryToMeshService = new GeometryToMeshService();
export default geometryToMeshService;

export interface MaterialZone {
  zoneId: string;
  zoneName: string;
  materialType: 'soil' | 'concrete' | 'steel';
  faceIndices: number[];
  properties: {
    density: number;
    elasticModulus: number;
    poissonRatio: number;
    cohesion?: number;
    frictionAngle?: number;
    permeability?: number;
  };
}

export interface GeometryToMeshData {
  header: {
    version: string;
    timestamp: string;
    geometryType: 'geology' | 'excavation' | 'support';
    coordinateSystem: string;
    units: string;
  };
  
  // 核心几何数据
  meshGeometry: {
    vertices: Float32Array;
    faces: Uint32Array;
    normals: Float32Array;
    vertexCount: number;
    faceCount: number;
  };
  
  // 材料分区
  materialZones: MaterialZone[];
  
  // 网格指导
  meshGuidance: {
    globalElementSize: number;
    localRefinement: Array<{
      region: string;
      faceIndices: number[];
      targetSize: number;
      priority: 'high' | 'medium' | 'low';
    }>;
    qualityRequirements: {
      minAngle: number;
      maxAspectRatio: number;
      targetQuality: number;
    };
  };
}

class GeometryToMeshService {
  private baseUrl: string;

  constructor() {
    this.baseUrl = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:8080'
      : window.location.origin;
  }

  /**
   * 将DXF边界转换为基坑几何数据
   */
  async convertDXFToExcavation(
    dxfBoundary: Point3D[],
    depth: number,
    surfaceElevation: number
  ): Promise<GeometryToMeshData> {
    
    const vertices: number[] = [];
    const faces: number[] = [];
    const normals: number[] = [];
    
    // 生成顶部边界顶点
    dxfBoundary.forEach(point => {
      vertices.push(point.x, point.y, surfaceElevation);
      normals.push(0, 0, 1);
    });
    
    // 生成底部边界顶点
    dxfBoundary.forEach(point => {
      vertices.push(point.x, point.y, surfaceElevation - depth);
      normals.push(0, 0, -1);
    });
    
    const n = dxfBoundary.length;
    
    // 生成底面三角形
    for (let i = 1; i < n - 1; i++) {
      faces.push(n, n + i, n + i + 1);
    }
    
    // 生成侧面三角形
    for (let i = 0; i < n; i++) {
      const next = (i + 1) % n;
      faces.push(i, next, next + n);
      faces.push(i, next + n, i + n);
    }
    
    return {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'excavation',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array(vertices),
        faces: new Uint32Array(faces),
        normals: new Float32Array(normals),
        vertexCount: vertices.length / 3,
        faceCount: faces.length / 3
      },
      materialZones: [{
        zoneId: 'excavation_air',
        zoneName: '开挖空间',
        materialType: 'soil',
        faceIndices: Array.from({ length: faces.length / 3 }, (_, i) => i),
        properties: {
          density: 1.225,
          elasticModulus: 1000,
          poissonRatio: 0.3
        }
      }],
      meshGuidance: {
        globalElementSize: 2.0,
        localRefinement: [{
          region: 'excavation_corners',
          faceIndices: [0, 1, 2, 3],
          targetSize: 1.0,
          priority: 'high'
        }],
        qualityRequirements: {
          minAngle: 20,
          maxAspectRatio: 10,
          targetQuality: 0.8
        }
      }
    };
  }

  /**
   * 将地质数据转换为网格数据
   */
  async convertGeologyToMesh(
    geologyLayers: Array<{
      layerId: number;
      vertices: Point3D[];
      soilType: string;
      properties: any;
    }>
  ): Promise<GeometryToMeshData> {
    
    const allVertices: number[] = [];
    const allFaces: number[] = [];
    const allNormals: number[] = [];
    const materialZones: MaterialZone[] = [];
    
    let vertexOffset = 0;
    
    for (const layer of geologyLayers) {
      const layerVertices = layer.vertices;
      const startIndex = vertexOffset;
      
      // 添加顶点
      layerVertices.forEach(v => {
        allVertices.push(v.x, v.y, v.z);
        allNormals.push(0, 0, 1);
      });
      
      // 生成三角形面 (简单三角剖分)
      const layerFaces: number[] = [];
      for (let i = 1; i < layerVertices.length - 1; i++) {
        allFaces.push(startIndex, startIndex + i, startIndex + i + 1);
        layerFaces.push(allFaces.length / 3 - 1);
      }
      
      // 材料分区
      materialZones.push({
        zoneId: `layer_${layer.layerId}`,
        zoneName: layer.soilType,
        materialType: 'soil',
        faceIndices: layerFaces,
        properties: layer.properties
      });
      
      vertexOffset += layerVertices.length;
    }
    
    return {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'geology',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array(allVertices),
        faces: new Uint32Array(allFaces),
        normals: new Float32Array(allNormals),
        vertexCount: allVertices.length / 3,
        faceCount: allFaces.length / 3
      },
      materialZones,
      meshGuidance: {
        globalElementSize: 2.0,
        localRefinement: [],
        qualityRequirements: {
          minAngle: 15,
          maxAspectRatio: 15,
          targetQuality: 0.7
        }
      }
    };
  }

  /**
   * 发送几何数据给3号网格生成
   */
  async sendToMeshGenerator(data: GeometryToMeshData): Promise<{
    success: boolean;
    meshJobId: string;
    estimatedTime: number;
  }> {
    try {
      console.log('🔧 发送几何数据给3号网格生成');
      
      const response = await fetch(`${this.baseUrl}/api/meshing/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error(`网格生成请求失败: ${response.status}`);
      }

      const result = await response.json();
      console.log('✅ 网格生成任务已提交:', result);
      
      return result;
    } catch (error) {
      console.error('❌ 发送网格数据失败:', error);
      throw error;
    }
  }

  /**
   * 查询网格生成状态
   */
  async getMeshingStatus(jobId: string): Promise<{
    status: 'pending' | 'processing' | 'completed' | 'failed';
    progress: number;
    result?: any;
    error?: string;
  }> {
    try {
      const response = await fetch(`${this.baseUrl}/api/meshing/status/${jobId}`);
      return await response.json();
    } catch (error) {
      console.error('查询网格状态失败:', error);
      throw error;
    }
  }

  /**
   * 组合完整的CAE数据流
   */
  async processCompleteCAEWorkflow(
    dxfBoundary: Point3D[],
    geologyData: any[],
    excavationDepth: number,
    surfaceElevation: number
  ): Promise<string> {
    
    console.log('🚀 开始完整CAE工作流');
    
    // 1. 转换基坑几何
    const excavationData = await this.convertDXFToExcavation(
      dxfBoundary, 
      excavationDepth, 
      surfaceElevation
    );
    
    // 2. 转换地质数据
    const geologyMeshData = await this.convertGeologyToMesh(geologyData);
    
    // 3. 合并数据
    const combinedData: GeometryToMeshData = {
      header: {
        version: '1.0',
        timestamp: new Date().toISOString(),
        geometryType: 'excavation',
        coordinateSystem: 'LOCAL',
        units: 'meters'
      },
      meshGeometry: {
        vertices: new Float32Array([
          ...excavationData.meshGeometry.vertices,
          ...geologyMeshData.meshGeometry.vertices
        ]),
        faces: new Uint32Array([
          ...excavationData.meshGeometry.faces,
          ...Array.from(geologyMeshData.meshGeometry.faces).map(
            f => f + excavationData.meshGeometry.vertexCount
          )
        ]),
        normals: new Float32Array([
          ...excavationData.meshGeometry.normals,
          ...geologyMeshData.meshGeometry.normals
        ]),
        vertexCount: excavationData.meshGeometry.vertexCount + geologyMeshData.meshGeometry.vertexCount,
        faceCount: excavationData.meshGeometry.faceCount + geologyMeshData.meshGeometry.faceCount
      },
      materialZones: [
        ...excavationData.materialZones,
        ...geologyMeshData.materialZones
      ],
      meshGuidance: excavationData.meshGuidance
    };
    
    // 4. 发送给3号
    const meshJob = await this.sendToMeshGenerator(combinedData);
    
    console.log('✅ CAE工作流启动完成，网格任务ID:', meshJob.meshJobId);
    
    return meshJob.meshJobId;
  }
}

// 创建单例
export const geometryToMeshService = new GeometryToMeshService();

// 便捷函数
export const processCAEWorkflow = (
  dxfBoundary: Point3D[],
  geologyData: any[],
  excavationDepth: number,
  surfaceElevation: number
) => geometryToMeshService.processCompleteCAEWorkflow(
  dxfBoundary, 
  geologyData, 
  excavationDepth, 
  surfaceElevation
);

export default geometryToMeshService;