<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>geo-threeç“¦ç‰‡æ¸²æŸ“æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Monaco', 'Menlo', monospace;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ffff;
            z-index: 1000;
            max-width: 400px;
            font-size: 12px;
            line-height: 1.4;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ffffff;
            z-index: 1000;
        }

        button {
            background: #0080ff;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        button:hover {
            background: #00aaff;
        }

        .status {
            color: #00ff00;
            font-weight: bold;
        }

        .error {
            color: #ff4444;
            font-weight: bold;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h3 style="margin: 0 0 10px 0; color: #00ffff;">ğŸ—ºï¸ geo-threeç“¦ç‰‡æ¸²æŸ“æµ‹è¯•</h3>
        <div id="status">åˆå§‹åŒ–ä¸­...</div>
        <div style="margin-top: 10px;">
            <div>ç“¦ç‰‡åŠ è½½çŠ¶æ€ï¼š<span id="tile-status">ç­‰å¾…ä¸­</span></div>
            <div>å·²åŠ è½½ç“¦ç‰‡ï¼š<span id="tile-count">0</span></div>
            <div>æ¸²æŸ“å¸§ç‡ï¼š<span id="fps">0</span> FPS</div>
            <div>ç›¸æœºä½ç½®ï¼š<span id="camera-pos">æœªçŸ¥</span></div>
        </div>
    </div>

    <div id="controls">
        <h4 style="margin: 0 0 10px 0;">åœ°å›¾æ§åˆ¶</h4>
        <button onclick="switchMapStyle('street')">ğŸ—ºï¸ è¡—é“</button>
        <button onclick="switchMapStyle('satellite')">ğŸ›°ï¸ å«æ˜Ÿ</button>
        <button onclick="switchMapStyle('terrain')">â›°ï¸ åœ°å½¢</button>
        <button onclick="switchMapStyle('dark')">ğŸŒ™ æš—è‰²</button>
        <br/>
        <button onclick="addTestMarkers()">ğŸ“Œ æ·»åŠ æµ‹è¯•æ ‡è®°</button>
        <button onclick="flyToShanghai()">âœˆï¸ é£å¾€ä¸Šæµ·</button>
        <button onclick="resetView()">ğŸ”„ é‡ç½®è§†å›¾</button>
    </div>

    <!-- å¼•å…¥Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
    
    <script>
        console.log('ğŸš€ å¼€å§‹geo-threeç“¦ç‰‡æ¸²æŸ“æµ‹è¯•...');
        
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let tiles = new Map();
        let currentStyle = 'street';
        let center = { lat: 31.2304, lng: 121.4737 }; // ä¸Šæµ·
        let zoom = 8;
        let tileScale = 10;
        let frameCount = 0;
        let lastTime = performance.now();

        // ç“¦ç‰‡æä¾›è€…ç±»
        class TileProvider {
            constructor() {
                this.styleUrls = {
                    street: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    satellite: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
                    terrain: 'https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',
                    dark: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png'
                };
            }

            getTileUrl(style, zoom, x, y) {
                const template = this.styleUrls[style] || this.styleUrls.street;
                return template
                    .replace('{z}', zoom.toString())
                    .replace('{x}', x.toString())
                    .replace('{y}', y.toString());
            }

            lngLatToTile(lng, lat, zoom) {
                const latRad = lat * Math.PI / 180;
                const n = Math.pow(2, zoom);
                const x = Math.floor((lng + 180) / 360 * n);
                const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);
                return { x, y, z: zoom };
            }

            getTileWorldPosition(tileX, tileY, centerTile, scale) {
                const offsetX = (tileX - centerTile.x) * scale;
                const offsetY = -(tileY - centerTile.y) * scale;
                return new THREE.Vector3(offsetX, 0, offsetY);
            }
        }

        // ç“¦ç‰‡ç±»
        class MapTile {
            constructor(tileCoord, worldPosition, scale) {
                this.tileCoord = tileCoord;
                this.worldPosition = worldPosition;
                this.scale = scale;
                this.texture = null;
                
                // åˆ›å»ºå‡ ä½•ä½“å’Œæè´¨
                this.geometry = new THREE.PlaneGeometry(scale, scale);
                this.material = new THREE.MeshBasicMaterial({ 
                    color: 0x66ccff,
                    transparent: false,
                    opacity: 1.0,
                    side: THREE.DoubleSide
                });
                
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.position.copy(worldPosition);
                this.mesh.rotation.x = -Math.PI / 2;
                
                this.loader = new THREE.TextureLoader();
                this.loader.crossOrigin = 'anonymous';
            }

            async loadTexture(provider, style) {
                return new Promise((resolve) => {
                    const url = provider.getTileUrl(style, this.tileCoord.z, this.tileCoord.x, this.tileCoord.y);
                    console.log(`ğŸŒ åŠ è½½ç“¦ç‰‡çº¹ç†: ${url}`);
                    
                    this.loader.load(
                        url,
                        (texture) => {
                            texture.flipY = false;
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            
                            // åº”ç”¨çº¹ç†
                            this.material.map = texture;
                            this.material.color.set(0xffffff);
                            this.material.needsUpdate = true;
                            this.texture = texture;
                            
                            console.log(`âœ… ç“¦ç‰‡çº¹ç†åŠ è½½æˆåŠŸ: ${this.tileCoord.z}/${this.tileCoord.x}/${this.tileCoord.y}`);
                            updateTileCount();
                            resolve();
                        },
                        (progress) => {
                            // console.log(`ğŸ“Š åŠ è½½è¿›åº¦: ${((progress.loaded / progress.total) * 100).toFixed(1)}%`);
                        },
                        (error) => {
                            console.warn(`âš ï¸ ç“¦ç‰‡åŠ è½½å¤±è´¥: ${this.tileCoord.z}/${this.tileCoord.x}/${this.tileCoord.y}`, error);
                            this.material.color.set(0xff6666);
                            this.material.needsUpdate = true;
                            resolve();
                        }
                    );
                });
            }
        }

        // åˆå§‹åŒ–Three.js
        function initThreeJS() {
            const container = document.getElementById('container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);
            scene.fog = new THREE.Fog(0x001122, 50, 200);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 25);
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(renderer.domElement);
            
            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            console.log('âœ… Three.jsåˆå§‹åŒ–å®Œæˆ');
            updateStatus('Three.jsåˆå§‹åŒ–å®Œæˆ', 'status');
        }

        // åŠ è½½å¯è§†ç“¦ç‰‡
        async function loadVisibleTiles() {
            console.log('ğŸ—ºï¸ å¼€å§‹åŠ è½½å¯è§†ç“¦ç‰‡...');
            updateStatus('æ­£åœ¨åŠ è½½ç“¦ç‰‡...', 'warning');
            
            const tileProvider = new TileProvider();
            const centerTile = tileProvider.lngLatToTile(center.lng, center.lat, zoom);
            const tileRadius = 3; // 3x3ç½‘æ ¼
            
            console.log(`ğŸ“Š ç“¦ç‰‡èŒƒå›´: ä¸­å¿ƒ(${centerTile.x}, ${centerTile.y}), åŠå¾„=${tileRadius}, ç¼©æ”¾=${zoom}`);
            
            const loadPromises = [];
            let tilesCreated = 0;
            
            for (let x = centerTile.x - tileRadius; x <= centerTile.x + tileRadius; x++) {
                for (let y = centerTile.y - tileRadius; y <= centerTile.y + tileRadius; y++) {
                    const tileKey = `${zoom}_${x}_${y}`;
                    
                    if (!tiles.has(tileKey)) {
                        const tileCoord = { x, y, z: zoom };
                        const worldPos = tileProvider.getTileWorldPosition(x, y, centerTile, tileScale);
                        
                        console.log(`ğŸ¯ åˆ›å»ºç“¦ç‰‡ ${tileKey} åœ¨ä½ç½® (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})`);
                        
                        const tile = new MapTile(tileCoord, worldPos, tileScale);
                        tiles.set(tileKey, tile);
                        scene.add(tile.mesh);
                        tilesCreated++;
                        
                        loadPromises.push(tile.loadTexture(tileProvider, currentStyle));
                    }
                }
            }
            
            console.log(`ğŸ”¨ åˆ›å»ºäº† ${tilesCreated} ä¸ªæ–°ç“¦ç‰‡`);
            
            if (loadPromises.length > 0) {
                console.log(`ğŸ”„ å¼€å§‹åŠ è½½ ${loadPromises.length} ä¸ªç“¦ç‰‡çº¹ç†...`);
                try {
                    await Promise.all(loadPromises);
                    console.log('âœ… æ‰€æœ‰ç“¦ç‰‡çº¹ç†åŠ è½½å®Œæˆ');
                    updateStatus('ç“¦ç‰‡åŠ è½½å®Œæˆ', 'status');
                } catch (error) {
                    console.error('âŒ ç“¦ç‰‡çº¹ç†åŠ è½½å¤±è´¥:', error);
                    updateStatus('ç“¦ç‰‡åŠ è½½å¤±è´¥', 'error');
                }
            } else {
                updateStatus('æ²¡æœ‰æ–°ç“¦ç‰‡éœ€è¦åŠ è½½', 'warning');
            }
        }

        // åˆ‡æ¢åœ°å›¾æ ·å¼
        async function switchMapStyle(style) {
            console.log(`ğŸ¨ åˆ‡æ¢åœ°å›¾æ ·å¼: ${style}`);
            currentStyle = style;
            updateStatus(`åˆ‡æ¢åˆ°${style}æ ·å¼...`, 'warning');
            
            const tileProvider = new TileProvider();
            const reloadPromises = [];
            
            tiles.forEach((tile) => {
                reloadPromises.push(tile.loadTexture(tileProvider, style));
            });
            
            if (reloadPromises.length > 0) {
                try {
                    await Promise.all(reloadPromises);
                    updateStatus(`${style}æ ·å¼åŠ è½½å®Œæˆ`, 'status');
                } catch (error) {
                    updateStatus(`${style}æ ·å¼åŠ è½½å¤±è´¥`, 'error');
                }
            }
        }

        // æ·»åŠ æµ‹è¯•æ ‡è®°
        function addTestMarkers() {
            console.log('ğŸ“Œ æ·»åŠ æµ‹è¯•é¡¹ç›®æ ‡è®°...');
            
            const projects = [
                { name: 'ä¸Šæµ·ä¸­å¿ƒ', pos: [0, 0, 0], color: 0x52c41a },
                { name: 'æµ‹è¯•é¡¹ç›®A', pos: [5, 0, 5], color: 0xfaad14 },
                { name: 'æµ‹è¯•é¡¹ç›®B', pos: [-5, 0, -5], color: 0x8c8c8c }
            ];
            
            projects.forEach(project => {
                const geometry = new THREE.CylinderGeometry(0.5, 0.75, 2, 16);
                const material = new THREE.MeshLambertMaterial({ 
                    color: project.color,
                    emissive: project.color,
                    emissiveIntensity: 0.2
                });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(...project.pos);
                marker.position.y = 1;
                scene.add(marker);
                
                console.log(`âœ… æ·»åŠ æ ‡è®°: ${project.name}`);
            });
            
            updateStatus('æµ‹è¯•æ ‡è®°å·²æ·»åŠ ', 'status');
        }

        // é£å¾€ä¸Šæµ·
        function flyToShanghai() {
            console.log('âœˆï¸ é£å¾€ä¸Šæµ·ä¸­å¿ƒ...');
            camera.position.set(0, 20, 20);
            camera.lookAt(0, 0, 0);
            updateStatus('é£å¾€ä¸Šæµ·ä¸­å¿ƒ', 'status');
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            console.log('ğŸ”„ é‡ç½®è§†å›¾...');
            camera.position.set(0, 25, 25);
            camera.lookAt(0, 0, 0);
            updateStatus('è§†å›¾å·²é‡ç½®', 'status');
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message, type = 'normal') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = type;
        }

        // æ›´æ–°ç“¦ç‰‡è®¡æ•°
        function updateTileCount() {
            let loadedCount = 0;
            tiles.forEach(tile => {
                if (tile.texture) loadedCount++;
            });
            document.getElementById('tile-count').textContent = loadedCount;
            document.getElementById('tile-status').textContent = `${loadedCount}/${tiles.size} å·²åŠ è½½`;
        }

        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // è®¡ç®—FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // æ›´æ–°ç›¸æœºä½ç½®æ˜¾ç¤º
            const pos = camera.position;
            document.getElementById('camera-pos').textContent = 
                `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
            
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // é¼ æ ‡æ§åˆ¶
        function setupControls() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                camera.position.x -= deltaMove.x * 0.02;
                camera.position.z -= deltaMove.y * 0.02;
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.y *= zoomFactor;
                camera.position.y = Math.max(2, Math.min(50, camera.position.y));
            });
        }

        // åˆå§‹åŒ–åº”ç”¨
        async function init() {
            try {
                console.log('ğŸš€ åˆå§‹åŒ–geo-threeæµ‹è¯•åº”ç”¨...');
                updateStatus('åˆå§‹åŒ–Three.js...', 'warning');
                
                initThreeJS();
                setupControls();
                
                // å»¶è¿ŸåŠ è½½ç“¦ç‰‡
                setTimeout(async () => {
                    await loadVisibleTiles();
                    animate();
                }, 500);
                
                window.addEventListener('resize', handleResize);
                
            } catch (error) {
                console.error('âŒ åˆå§‹åŒ–å¤±è´¥:', error);
                updateStatus('åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>